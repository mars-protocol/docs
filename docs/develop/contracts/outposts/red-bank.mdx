---
sidebar_position: 4
---

import RedBankInitAssetUrl from '@site/static/img//develop/contracts/red-bank-init-asset.png';
import RedBankUpdateAssetUrl from '@site/static/img//develop/contracts/red-bank-update-asset.png';
import RedBankDepositUrl from '@site/static/img//develop/contracts/red-bank-deposit.png';
import RedBankWithdrawUrl from '@site/static/img//develop/contracts/red-bank-withdraw.png';
import RedBankBorrowUrl from '@site/static/img//develop/contracts/red-bank-borrow.png';
import RedBankRepayUrl from '@site/static/img//develop/contracts/red-bank-repay.png';
import RedBankLiquidateUrl from '@site/static/img//develop/contracts/red-bank-liquidate.png';

# red-bank

The Red Bank exposes all interactions that are done between the user and the money market. It also holds all protocol liquidity.

## Links 

- **Contract address:** 
- **Testnet address:** `osmo18af4kd6pe34tnkm3vr7qlu872s0vpft83n69pvrtxy66e2cemnksxcdzxe`
- **Contract repo:** https://github.com/mars-protocol/outposts/tree/master/contracts/red-bank
- **contract.rs:** https://github.com/mars-protocol/outposts/blob/master/contracts/red-bank/src/contract.rs
- **execute.rs:** https://github.com/mars-protocol/outposts/blob/master/contracts/red-bank/src/execute.rs
- **query.rs:** https://github.com/mars-protocol/outposts/blob/master/contracts/red-bank/src/query.rs
- **Packages:** https://github.com/mars-protocol/outposts/tree/master/packages/outpost/src/red_bank
- **Tests:** https://github.com/mars-protocol/outposts/tree/master/contracts/red-bank/tests
- **Audit:** 

## InstantiateMsg

Instantiates the Red Bank contract.

<CH.Section>
<CH.Code>

```json json
{
    "config": {
        "owner": "...", 
        "address_provider": "...", 
        "close_factor": 0.123
    }
}
```

```rust msg.rs
#[cw_serde]
pub struct InstantiateMsg {
    pub config: CreateOrUpdateConfig,
}
```

```rust contract.rs
#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    execute::instantiate(deps, msg)
}
```

```rust test
#[test]
fn test_proper_initialization() {
    let mut deps = mock_dependencies(&[]);
    let env = mock_env(MockEnvParams::default());

    // Config with base params valid (just update the rest)
    let base_config = CreateOrUpdateConfig {
        owner: Some("owner".to_string()),
        address_provider: Some("address_provider".to_string()),
        close_factor: None,
    };

    // *
    // init config with empty params
    // *
    let empty_config = CreateOrUpdateConfig {
        owner: None,
        address_provider: None,
        close_factor: None,
    };
    let msg = InstantiateMsg {
        config: empty_config,
    };
    let info = mock_info("owner", &[]);
    let error_res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap_err();
    assert_eq!(error_res, MarsError::InstantiateParamsUnavailable {}.into());

    // *
    // init config with close_factor greater than 1
    // *
    let mut close_factor = Decimal::from_ratio(13u128, 10u128);
    let config = CreateOrUpdateConfig {
        close_factor: Some(close_factor),
        ..base_config.clone()
    };
    let msg = InstantiateMsg {
        config,
    };
    let info = mock_info("owner", &[]);
    let error_res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap_err();
    assert_eq!(
        error_res,
        MarsError::InvalidParam {
            param_name: "close_factor".to_string(),
            invalid_value: "1.3".to_string(),
            predicate: "<= 1".to_string(),
        }
        .into()
    );

    // *
    // init config with valid params
    // *
    close_factor = Decimal::from_ratio(1u128, 2u128);
    let config = CreateOrUpdateConfig {
        close_factor: Some(close_factor),
        ..base_config
    };
    let msg = InstantiateMsg {
        config,
    };

    // we can just call .unwrap() to assert this was a success
    let info = mock_info("owner", &[]);
    let res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();
    assert_eq!(0, res.messages.len());

    // it worked, let's query the state
    let res = query(deps.as_ref(), env, QueryMsg::Config {}).unwrap();
    let value: ConfigResponse = from_binary(&res).unwrap();
    assert_eq!(value.owner, "owner");
    assert_eq!(value.address_provider, "address_provider");
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`config`](focus://json#2:6)      | [`CreateOrUpdateConfig`](#createorupdateconfig)       | Market configuration       |

</CH.Section>

#### `CreateOrUpdateConfig`

<CH.Section>
<CH.Code>

```json json
{
    "owner": "...", 
    "address_provider": "...", 
    "close_factor": 0.123
}
```

```rust msg.rs
#[cw_serde]
pub struct CreateOrUpdateConfig {
    pub owner: Option<String>,
    pub address_provider: Option<String>,
    pub close_factor: Option<Decimal>,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`owner`](focus://json#2)      | `Option<String>`       | Contract owner       |
| [`address_provider`](focus://json#3)      | `Option<String>`       | Address provider returns addresses for all protocol contracts       |
| [`close_factor`](focus://json#4)      | `Option<Decimal>`       | Maximum percentage of outstanding debt that can be covered by a liquidator       |

</CH.Section>

## ExecuteMsg

### `update_config`

Updates the contract's config (only the owner of the contract can call)

<CH.Section>

<CH.Code>

```json json
{
    "update_config": {
        "config": {
            "owner": "...", 
            "address_provider": "...", 
            "closer_factor": 0.123
        }
    }
}  
```

```rust msg.rs focus=1:6,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
``` 

```rust contract.rs focus=1:11,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs 
pub fn update_config(
    deps: DepsMut,
    info: MessageInfo,
    new_config: CreateOrUpdateConfig,
) -> Result<Response, ContractError> {
    let mut config = CONFIG.load(deps.storage)?;

    if info.sender != config.owner {
        return Err(MarsError::Unauthorized {}.into());
    }

    // Destructuring a struct’s fields into separate variables in order to force
    // compile error if we add more params
    let CreateOrUpdateConfig {
        owner,
        address_provider,
        close_factor,
    } = new_config;

    // Update config
    config.owner = option_string_to_addr(deps.api, owner, config.owner)?;
    config.address_provider =
        option_string_to_addr(deps.api, address_provider, config.address_provider)?;
    config.close_factor = close_factor.unwrap_or(config.close_factor);

    // Validate config
    config.validate()?;

    CONFIG.save(deps.storage, &config)?;

    Ok(Response::new().add_attribute("action", "outposts/red-bank/update_config"))
}
```

```rust test
#[test]
fn test_update_config() {
    let mut deps = mock_dependencies(&[]);
    let env = mock_env(MockEnvParams::default());

    // *
    // init config with valid params
    // *
    let mut close_factor = Decimal::from_ratio(1u128, 4u128);
    let init_config = CreateOrUpdateConfig {
        owner: Some("owner".to_string()),
        address_provider: Some("address_provider".to_string()),
        close_factor: Some(close_factor),
    };
    let msg = InstantiateMsg {
        config: init_config.clone(),
    };
    // we can just call .unwrap() to assert this was a success
    let info = mock_info("owner", &[]);
    let _res = instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();

    // *
    // non owner is not authorized
    // *
    let msg = ExecuteMsg::UpdateConfig {
        config: init_config.clone(),
    };
    let info = mock_info("somebody", &[]);
    let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
    assert_eq!(error_res, MarsError::Unauthorized {}.into());

    // *
    // update config with close_factor
    // *
    close_factor = Decimal::from_ratio(13u128, 10u128);
    let config = CreateOrUpdateConfig {
        owner: None,
        close_factor: Some(close_factor),
        ..init_config
    };
    let msg = ExecuteMsg::UpdateConfig {
        config,
    };
    let info = mock_info("owner", &[]);
    let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
    assert_eq!(
        error_res,
        MarsError::InvalidParam {
            param_name: "close_factor".to_string(),
            invalid_value: "1.3".to_string(),
            predicate: "<= 1".to_string(),
        }
        .into()
    );

    // *
    // update config with all new params
    // *
    close_factor = Decimal::from_ratio(1u128, 20u128);
    let config = CreateOrUpdateConfig {
        owner: Some("new_owner".to_string()),
        address_provider: Some("new_address_provider".to_string()),
        close_factor: Some(close_factor),
    };
    let msg = ExecuteMsg::UpdateConfig {
        config: config.clone(),
    };

    // we can just call .unwrap() to assert this was a success
    let info = mock_info("owner", &[]);
    let res = execute(deps.as_mut(), env, info, msg).unwrap();
    assert_eq!(0, res.messages.len());

    // Read config from state
    let new_config = CONFIG.load(&deps.storage).unwrap();

    assert_eq!(new_config.owner, Addr::unchecked("new_owner"));
    assert_eq!(new_config.address_provider, Addr::unchecked(config.address_provider.unwrap()));
    assert_eq!(new_config.close_factor, config.close_factor.unwrap());
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`config`](focus://json#3:7)      | [`CreateOrUpdateConfig`](#createorupdateconfig)       | Market configuration       |

</CH.Section>

### `init_asset`

Initializes an asset on the money market (only the owner of the contract can call)

<CH.Section>

<CH.Code>

```json json
{
    "init_asset": {
        "denom": "...", 
        "params": {
            "initial_borrow_rate": 0.123, 
            "reserve_factor": 0.123, 
            "max_loan_to_value": 0.123, 
            "liquidation_threshold": 0.123, 
            "interest_rate_model": {
                "optimal_utilization_rate": 0.123, 
                "base": 0.123, 
                "slope_1": 0.123, 
                "slope_2": 0.123
            }, 
            "desposit_enabled": true, 
            "borrow_enabled": true, 
            "deposit_cap": 123
        }
    }
}
```

```rust msg.rs focus=1:3,7:10,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,12:15,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn init_asset(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    params: InitOrUpdateAssetParams,
) -> Result<Response, ContractError> {
    let config = CONFIG.load(deps.storage)?;

    if info.sender != config.owner {
        return Err(MarsError::Unauthorized {}.into());
    }

    if MARKETS.may_load(deps.storage, &denom)?.is_some() {
        return Err(ContractError::AssetAlreadyInitialized {});
    }

    let new_market = create_market(env.block.time.seconds(), &denom, params)?;
    MARKETS.save(deps.storage, &denom, &new_market)?;

    Ok(Response::new()
        .add_attribute("action", "outposts/red-bank/init_asset")
        .add_attribute("denom", denom))
}
```

```rust test
#[test]
fn test_init_asset() {
    let mut deps = mock_dependencies(&[]);
    let env = mock_env(MockEnvParams::default());

    let config = CreateOrUpdateConfig {
        owner: Some("owner".to_string()),
        address_provider: Some("address_provider".to_string()),
        close_factor: Some(Decimal::from_ratio(1u128, 2u128)),
    };
    let msg = InstantiateMsg {
        config,
    };
    let info = mock_info("owner", &[]);
    instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();

    let ir_model = InterestRateModel {
        optimal_utilization_rate: Decimal::one(),
        base: Decimal::percent(5),
        slope_1: Decimal::zero(),
        slope_2: Decimal::zero(),
    };

    let params = InitOrUpdateAssetParams {
        initial_borrow_rate: Some(Decimal::from_ratio(20u128, 100u128)),
        max_loan_to_value: Some(Decimal::from_ratio(8u128, 10u128)),
        reserve_factor: Some(Decimal::from_ratio(1u128, 100u128)),
        liquidation_threshold: Some(Decimal::one()),
        liquidation_bonus: Some(Decimal::zero()),
        interest_rate_model: Some(ir_model.clone()),
        deposit_enabled: Some(true),
        borrow_enabled: Some(true),
        deposit_cap: None,
    };

    // non owner is not authorized
    {
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("somebody", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(error_res, MarsError::Unauthorized {}.into());
    }

    // init asset with empty params
    {
        let empty_asset_params = InitOrUpdateAssetParams {
            max_loan_to_value: None,
            liquidation_threshold: None,
            liquidation_bonus: None,
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: empty_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(error_res, MarsError::InstantiateParamsUnavailable {}.into());
    }

    // init asset with reserve_factor equal to 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            reserve_factor: Some(Decimal::one()),
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "reserve_factor".to_string(),
                invalid_value: "1".to_string(),
                predicate: "< 1".to_string(),
            }
            .into()
        );
    }

    // init asset with max_loan_to_value greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            max_loan_to_value: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "max_loan_to_value".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // init asset with liquidation_threshold greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            liquidation_threshold: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_threshold".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // init asset with liquidation_bonus greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            liquidation_bonus: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_bonus".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // init asset where LTV >= liquidity threshold
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            max_loan_to_value: Some(Decimal::from_ratio(5u128, 10u128)),
            liquidation_threshold: Some(Decimal::from_ratio(5u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_threshold".to_string(),
                invalid_value: "0.5".to_string(),
                predicate: "> 0.5 (max LTV)".to_string()
            }
            .into()
        );
    }

    // init asset where optimal utilization rate > 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            interest_rate_model: Some(InterestRateModel {
                optimal_utilization_rate: Decimal::percent(110),
                ..ir_model
            }),
            ..params
        };
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "optimal_utilization_rate".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string()
            }
            .into()
        );
    }

    // owner is authorized
    {
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("owner", &[]);
        let res = execute(deps.as_mut(), env.clone(), info, msg).unwrap();

        // should have asset market with Canonical default address
        let market = MARKETS.load(&deps.storage, "someasset").unwrap();
        assert_eq!(market.denom, "someasset");

        // should have unlimited deposit cap
        assert_eq!(market.deposit_cap, Uint128::MAX);

        assert_eq!(
            res.attributes,
            vec![attr("action", "outposts/red-bank/init_asset"), attr("denom", "someasset")]
        );
    }

    // can't init more than once
    {
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
        assert_eq!(error_res, ContractError::AssetAlreadyInitialized {});
    }
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)      | `String`       | Asset related info       |
| [`params`](focus://json#4:18)      | [`InitOrUpdateAssetParams`](#initorupdateassetparams)       | Asset parameters       |

</CH.Section>

<img src={RedBankInitAssetUrl} />

#### `InitOrUpdateAssetParams`

<CH.Section>
<CH.Code>

```json json
{
    "initial_borrow_rate": 0.123, 
    "reserve_factor": 0.123, 
    "max_loan_to_value": 0.123, 
    "liquidation_treshold": 0.123, 
    "liquidation_bonus": 0.123, 
    "interest_rate_model": {
        "optimal_utilization_rate": 0.123, 
        "base": 0.123, 
        "slope_1": 0.123, 
        "slope_2": 0.123
    },
    "desposit_enabled": true, 
    "borrow_enabled": true, 
    "deposit_cap": 123
}
```

```rust msg.rs
#[cw_serde]
pub struct InitOrUpdateAssetParams {
    pub initial_borrow_rate: Option<Decimal>,
    pub reserve_factor: Option<Decimal>,
    pub max_loan_to_value: Option<Decimal>,
    pub liquidation_threshold: Option<Decimal>,
    pub liquidation_bonus: Option<Decimal>,
    pub interest_rate_model: Option<InterestRateModel>,
    pub deposit_enabled: Option<bool>,
    pub borrow_enabled: Option<bool>,
    pub deposit_cap: Option<Uint128>,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`initial_borrow_rate`](focus://json#2)      | `Option<Decimal>`       | Initial borrow rate       |
| [`reserve_factor`](focus://json#3)      | `Option<Decimal>`       | Portion of the borrow rate that is kept as protocol rewards       |
| [`max_loan_to_value`](focus://json#4)      | `Option<Decimal>`       | Max uusd that can be borrowed per uusd of collateral when using the asset as collateral       |
| [`liquidation_threshold`](focus://json#5)      | `Option<Decimal>`       | uusd amount in debt position per uusd of asset collateral that if surpassed makes the user's position liquidatable       |
| [`liquidation_bonus`](focus://json#6)      | `Option<Decimal>`       | Bonus amount of collateral liquidator get when repaying user's debt (Will get collateral from user in an amount equal to debt repayed + bonus)       |
| [`interest_rate_model`](focus://json#7:12)      | [`Option<InterestRateModel>`](#interestratemodel)       | Interest rate strategy to calculate borrow_rate and liquidity_rate       |
| [`deposit_enabled`](focus://json#13)      | `Option<bool>`       | If false cannot deposit       |
| [`borrow_enabled`](focus://json#14)      | `Option<bool>`       | If false cannot borrow       |
| [`deposit_cap`](focus://json#15)      | `Option<Uint128>`       | Deposit Cap defined in terms of the asset (Unlimited by default)       |


</CH.Section>


#### `InterestRateModel`

<CH.Section>

<CH.Code>

```json json
{
    "optimal_utilization_rate": 0.123, 
    "base": 0.123, 
    "slope_1": 0.123, 
    "slope_2": 0.123
}
```

```rust interest_rate_model.rs
#[cw_serde]
#[derive(Eq, Default)]
pub struct InterestRateModel {
    pub optimal_utilization_rate: Decimal,
    pub base: Decimal,
    pub slope_1: Decimal,
    pub slope_2: Decimal,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`optimal_utilization_rate`](focus://json#2)      | `Decimal`       | Optimal utilization rate       |
| [`base`](focus://json#3)      | `Decimal`       | Base rate       |
| [`slope_1`](focus://json#4)      | `Decimal`       | Slope parameter for interest rate model function when utilization_rate < optimal_utilization_rate       |
| [`slope_2`](focus://json#5)      | `Decimal`       | Slope parameter for interest rate model function when utilization_rate >= optimal_utilization_rate       |

</CH.Section>

### `update_asset`

Update an asset on the money market (only owner can call)

<CH.Section>

<CH.Code>

```json json
{
    "update_asset": {
        "denom": "...", 
        "params": {
            "initial_borrow_rate": 0.123, 
            "reserve_factor": 0.123, 
            "max_loan_to_value": 0.123, 
            "liquidation_threshold": 0.123, 
            "interest_rate_model": {
                "optimal_utilization_rate": 0.123, 
                "base": 0.123, 
                "slope_1": 0.123, 
                "slope_2": 0.123
            }, 
            "desposit_enabled": true, 
            "borrow_enabled": true, 
            "deposit_cap": 123
        }
    }
}
```

```rust msg.rs focus=1:3,11:14,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,16:19,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn update_asset(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    params: InitOrUpdateAssetParams,
) -> Result<Response, ContractError> {
    let config = CONFIG.load(deps.storage)?;

    if info.sender != config.owner {
        return Err(MarsError::Unauthorized {}.into());
    }

    let market_option = MARKETS.may_load(deps.storage, &denom)?;
    match market_option {
        None => Err(ContractError::AssetNotInitialized {}),
        Some(mut market) => {
            // Destructuring a struct’s fields into separate variables in order to force
            // compile error if we add more params
            let InitOrUpdateAssetParams {
                initial_borrow_rate: _,
                max_loan_to_value,
                reserve_factor,
                liquidation_threshold,
                liquidation_bonus,
                interest_rate_model,
                deposit_enabled,
                borrow_enabled,
                deposit_cap,
            } = params;

            // If reserve factor or interest rates are updated we update indexes with
            // current values before applying the change to prevent applying this
            // new params to a period where they were not valid yet. Interests rates are
            // recalculated after changes are applied.
            let should_update_interest_rates = (reserve_factor.is_some()
                && reserve_factor.unwrap() != market.reserve_factor)
                || interest_rate_model.is_some();

            let mut response = Response::new();

            if should_update_interest_rates {
                let addresses = address_provider::helpers::query_addresses(
                    deps.as_ref(),
                    &config.address_provider,
                    vec![MarsAddressType::Incentives, MarsAddressType::RewardsCollector],
                )?;
                let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
                let incentives_addr = &addresses[&MarsAddressType::Incentives];

                response = apply_accumulated_interests(
                    deps.storage,
                    &env,
                    &mut market,
                    rewards_collector_addr,
                    incentives_addr,
                    response,
                )?;
            }

            let mut updated_market = Market {
                max_loan_to_value: max_loan_to_value.unwrap_or(market.max_loan_to_value),
                reserve_factor: reserve_factor.unwrap_or(market.reserve_factor),
                liquidation_threshold: liquidation_threshold
                    .unwrap_or(market.liquidation_threshold),
                liquidation_bonus: liquidation_bonus.unwrap_or(market.liquidation_bonus),
                interest_rate_model: interest_rate_model.unwrap_or(market.interest_rate_model),
                deposit_enabled: deposit_enabled.unwrap_or(market.deposit_enabled),
                borrow_enabled: borrow_enabled.unwrap_or(market.borrow_enabled),
                deposit_cap: deposit_cap.unwrap_or(market.deposit_cap),
                ..market
            };

            updated_market.validate()?;

            if should_update_interest_rates {
                response = update_interest_rates(
                    &deps,
                    &env,
                    &mut updated_market,
                    Uint128::zero(),
                    &denom,
                    response,
                )?;
            }
            MARKETS.save(deps.storage, &denom, &updated_market)?;

            Ok(response
                .add_attribute("action", "outposts/red-bank/update_asset")
                .add_attribute("denom", &denom))
        }
    }
}
```

```rust test
#[test]
fn test_update_asset() {
    let mut deps = mock_dependencies(&[]);
    let start_time = 100000000;
    let env = mock_env_at_block_time(start_time);

    let config = CreateOrUpdateConfig {
        owner: Some("owner".to_string()),
        address_provider: Some("address_provider".to_string()),
        close_factor: Some(Decimal::from_ratio(1u128, 2u128)),
    };
    let msg = InstantiateMsg {
        config,
    };
    let info = mock_info("owner", &[]);
    instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();

    let ir_model = InterestRateModel {
        optimal_utilization_rate: Decimal::one(),
        base: Decimal::percent(5),
        slope_1: Decimal::zero(),
        slope_2: Decimal::zero(),
    };

    let params = InitOrUpdateAssetParams {
        initial_borrow_rate: Some(Decimal::from_ratio(20u128, 100u128)),
        max_loan_to_value: Some(Decimal::from_ratio(50u128, 100u128)),
        reserve_factor: Some(Decimal::from_ratio(1u128, 100u128)),
        liquidation_threshold: Some(Decimal::from_ratio(80u128, 100u128)),
        liquidation_bonus: Some(Decimal::from_ratio(10u128, 100u128)),
        interest_rate_model: Some(ir_model.clone()),
        deposit_enabled: Some(true),
        borrow_enabled: Some(true),
        deposit_cap: None,
    };

    // non owner is not authorized
    {
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("somebody", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(error_res, MarsError::Unauthorized {}.into());
    }

    // owner is authorized but can't update asset if not initialized first
    {
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(error_res, ContractError::AssetNotInitialized {});
    }

    // initialize asset
    {
        let msg = ExecuteMsg::InitAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("owner", &[]);
        let _res = execute(deps.as_mut(), env.clone(), info, msg).unwrap();
    }

    // update asset with max_loan_to_value greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            max_loan_to_value: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "max_loan_to_value".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // update asset with liquidation_threshold greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            liquidation_threshold: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_threshold".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // update asset with liquidation_bonus greater than 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            liquidation_bonus: Some(Decimal::from_ratio(11u128, 10u128)),
            ..params.clone()
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_bonus".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string(),
            }
            .into()
        );
    }

    // update asset where LTV >= liquidity threshold
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            max_loan_to_value: Some(Decimal::from_ratio(6u128, 10u128)),
            liquidation_threshold: Some(Decimal::from_ratio(5u128, 10u128)),
            ..params
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "liquidation_threshold".to_string(),
                invalid_value: "0.5".to_string(),
                predicate: "> 0.6 (max LTV)".to_string()
            }
            .into()
        );
    }

    // update asset where optimal utilization rate > 1
    {
        let invalid_asset_params = InitOrUpdateAssetParams {
            interest_rate_model: Some(InterestRateModel {
                optimal_utilization_rate: Decimal::percent(110),
                ..ir_model
            }),
            ..params
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: invalid_asset_params,
        };
        let info = mock_info("owner", &[]);
        let error_res = execute(deps.as_mut(), env.clone(), info, msg).unwrap_err();
        assert_eq!(
            error_res,
            MarsError::InvalidParam {
                param_name: "optimal_utilization_rate".to_string(),
                invalid_value: "1.1".to_string(),
                predicate: "<= 1".to_string()
            }
            .into()
        );
    }

    // update asset with new params
    {
        let params = InitOrUpdateAssetParams {
            initial_borrow_rate: Some(Decimal::from_ratio(20u128, 100u128)),
            max_loan_to_value: Some(Decimal::from_ratio(60u128, 100u128)),
            reserve_factor: Some(Decimal::from_ratio(10u128, 100u128)),
            liquidation_threshold: Some(Decimal::from_ratio(90u128, 100u128)),
            liquidation_bonus: Some(Decimal::from_ratio(12u128, 100u128)),
            interest_rate_model: Some(ir_model),
            deposit_enabled: Some(true),
            borrow_enabled: Some(true),
            deposit_cap: Some(Uint128::new(10_000_000)),
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: params.clone(),
        };
        let info = mock_info("owner", &[]);

        let res = execute(deps.as_mut(), env.clone(), info, msg).unwrap();
        assert_eq!(res.messages, vec![],);
        assert_eq!(
            res.attributes,
            vec![attr("action", "outposts/red-bank/update_asset"), attr("denom", "someasset")],
        );

        let new_market = MARKETS.load(&deps.storage, "someasset").unwrap();
        assert_eq!(params.max_loan_to_value.unwrap(), new_market.max_loan_to_value);
        assert_eq!(params.reserve_factor.unwrap(), new_market.reserve_factor);
        assert_eq!(params.liquidation_threshold.unwrap(), new_market.liquidation_threshold);
        assert_eq!(params.liquidation_bonus.unwrap(), new_market.liquidation_bonus);
        assert_eq!(params.interest_rate_model.unwrap(), new_market.interest_rate_model);
    }

    // update asset with empty params
    {
        let market_before = MARKETS.load(&deps.storage, "someasset").unwrap();

        let empty_asset_params = InitOrUpdateAssetParams {
            initial_borrow_rate: None,
            max_loan_to_value: None,
            reserve_factor: None,
            liquidation_threshold: None,
            liquidation_bonus: None,
            interest_rate_model: None,
            deposit_enabled: None,
            borrow_enabled: None,
            deposit_cap: None,
        };
        let msg = ExecuteMsg::UpdateAsset {
            denom: "someasset".to_string(),
            params: empty_asset_params,
        };
        let info = mock_info("owner", &[]);
        let res = execute(deps.as_mut(), env, info, msg).unwrap();

        // no interest updated event
        assert_eq!(res.events.len(), 0);

        let new_market = MARKETS.load(&deps.storage, "someasset").unwrap();
        // should keep old params
        assert_eq!(market_before.borrow_rate, new_market.borrow_rate);
        assert_eq!(market_before.max_loan_to_value, new_market.max_loan_to_value);
        assert_eq!(market_before.reserve_factor, new_market.reserve_factor);
        assert_eq!(market_before.liquidation_threshold, new_market.liquidation_threshold);
        assert_eq!(market_before.liquidation_bonus, new_market.liquidation_bonus);
        assert_eq!(market_before.deposit_cap, new_market.deposit_cap);
        assert_eq!(market_before.interest_rate_model, new_market.interest_rate_model);
    }
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)      | `String`       | Asset related info       |
| [`params`](focus://json#4:18)      | [`InitOrUpdateAssetParams`](#initorupdateassetparams)       | Asset parameters       |

</CH.Section>

<img src={RedBankUpdateAssetUrl} />

### `update_uncollateralized_loan_limit`

Update uncollateralized loan limit for a given user and asset. Overrides previous value if any. A limit of zero means no uncollateralized limit and the debt in that asset needs to be collateralized (only owner can call).

<CH.Section>
<CH.Code>

```json json
{
    "update_uncollateralized_loan_limit": {
        "user": "...", 
        "denom": "...", 
        "new_limit": 123
    }
}
```

```rust msg.rs focus=1:3,15:19,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,20:27,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn update_uncollateralized_loan_limit(
    deps: DepsMut,
    info: MessageInfo,
    user_addr: Addr,
    denom: String,
    new_limit: Uint128,
) -> Result<Response, ContractError> {
    // Get config
    let config = CONFIG.load(deps.storage)?;

    // Only owner can do this
    if info.sender != config.owner {
        return Err(MarsError::Unauthorized {}.into());
    }

    // Check that the user has no collateralized debt
    let current_limit = UNCOLLATERALIZED_LOAN_LIMITS
        .may_load(deps.storage, (&user_addr, &denom))?
        .unwrap_or_else(Uint128::zero);
    let current_debt = DEBTS
        .may_load(deps.storage, (&user_addr, &denom))?
        .map(|debt| debt.amount_scaled)
        .unwrap_or_else(Uint128::zero);
    if current_limit.is_zero() && !current_debt.is_zero() {
        return Err(ContractError::UserHasCollateralizedDebt {});
    }

    UNCOLLATERALIZED_LOAN_LIMITS.save(deps.storage, (&user_addr, &denom), &new_limit)?;

    DEBTS.update(deps.storage, (&user_addr, &denom), |debt_opt: Option<Debt>| -> StdResult<_> {
        let mut debt = debt_opt.unwrap_or(Debt {
            amount_scaled: Uint128::zero(),
            uncollateralized: false,
        });
        // if limit == 0 then uncollateralized = false, otherwise uncollateralized = true
        debt.uncollateralized = !new_limit.is_zero();
        Ok(debt)
    })?;

    Ok(Response::new()
        .add_attribute("action", "outposts/red-bank/update_uncollateralized_loan_limit")
        .add_attribute("user", user_addr)
        .add_attribute("denom", denom)
        .add_attribute("new_allowance", new_limit))
}
```

```rust test
#[test]
fn test_uncollateralized_loan_limits() {
    let available_liquidity = Uint128::from(2000000000u128);
    let mut deps = th_setup(&[coin(available_liquidity.into(), "somecoin")]);

    let mock_market = Market {
        borrow_index: Decimal::from_ratio(12u128, 10u128),
        liquidity_index: Decimal::from_ratio(8u128, 10u128),
        borrow_rate: Decimal::from_ratio(20u128, 100u128),
        liquidity_rate: Decimal::from_ratio(10u128, 100u128),
        reserve_factor: Decimal::from_ratio(1u128, 10u128),
        debt_total_scaled: Uint128::zero(),
        indexes_last_updated: 10000000,
        ..Default::default()
    };

    // should get index 0
    let market_initial = th_init_market(deps.as_mut(), "somecoin", &mock_market);

    let mut block_time = mock_market.indexes_last_updated + 10000u64;
    let initial_uncollateralized_loan_limit = Uint128::from(2400_u128);

    // Check that borrowers with uncollateralized debt cannot get an uncollateralized loan limit
    let existing_borrower_addr = Addr::unchecked("existing_borrower");
    set_debt(deps.as_mut(), &existing_borrower_addr, "somecoin", 123u128, false);

    let update_limit_msg = ExecuteMsg::UpdateUncollateralizedLoanLimit {
        denom: "somecoin".to_string(),
        user: existing_borrower_addr.to_string(),
        new_limit: initial_uncollateralized_loan_limit,
    };
    let update_limit_env = mock_env_at_block_time(block_time);
    let info = mock_info("owner", &[]);
    let err = execute(deps.as_mut(), update_limit_env.clone(), info, update_limit_msg).unwrap_err();
    assert_eq!(err, ContractError::UserHasCollateralizedDebt {});

    // Update uncollateralized loan limit for users without collateralized loans
    let borrower_addr = Addr::unchecked("borrower");

    let update_limit_msg = ExecuteMsg::UpdateUncollateralizedLoanLimit {
        denom: "somecoin".to_string(),
        user: borrower_addr.to_string(),
        new_limit: initial_uncollateralized_loan_limit,
    };

    // update limit as unauthorized user, should fail
    let info = mock_info("random", &[]);
    let error_res =
        execute(deps.as_mut(), update_limit_env.clone(), info, update_limit_msg.clone())
            .unwrap_err();
    assert_eq!(error_res, MarsError::Unauthorized {}.into());

    // Update borrower limit as owner
    let info = mock_info("owner", &[]);
    execute(deps.as_mut(), update_limit_env, info, update_limit_msg).unwrap();

    // check user's limit has been updated to the appropriate amount
    let limit =
        UNCOLLATERALIZED_LOAN_LIMITS.load(&deps.storage, (&borrower_addr, "somecoin")).unwrap();
    assert_eq!(limit, initial_uncollateralized_loan_limit);

    // check user's uncollateralized debt flag is true (limit > 0)
    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "somecoin")).unwrap();
    assert!(debt.uncollateralized);

    // Borrow asset
    block_time += 1000_u64;
    let initial_borrow_amount = initial_uncollateralized_loan_limit.multiply_ratio(1_u64, 2_u64);
    let borrow_msg = ExecuteMsg::Borrow {
        denom: "somecoin".to_string(),
        amount: initial_borrow_amount,
        recipient: None,
    };
    let borrow_env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    let res = execute(deps.as_mut(), borrow_env, info, borrow_msg).unwrap();

    let expected_params = th_get_expected_indices_and_rates(
        &market_initial,
        block_time,
        available_liquidity,
        TestUtilizationDeltaInfo {
            less_liquidity: initial_borrow_amount,
            more_debt: initial_borrow_amount,
            ..Default::default()
        },
    );

    let market = MARKETS.load(deps.as_ref().storage, "somecoin").unwrap();
    let expected_borrow_amount_scaled =
        get_scaled_debt_amount(initial_borrow_amount, &market, block_time).unwrap();

    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: borrower_addr.to_string(),
            amount: coins(initial_borrow_amount.u128(), "somecoin")
        }))]
    );

    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/borrow"),
            attr("sender", "borrower"),
            attr("recipient", "borrower"),
            attr("denom", "somecoin"),
            attr("amount", initial_borrow_amount),
            attr("amount_scaled", expected_borrow_amount_scaled),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event("somecoin", &expected_params)]);

    // Check debt
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "somecoin"));

    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "somecoin")).unwrap();

    let expected_debt_scaled_after_borrow = compute_scaled_amount(
        initial_borrow_amount,
        expected_params.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    assert_eq!(expected_debt_scaled_after_borrow, debt.amount_scaled);

    // Borrow an amount less than initial limit but exceeding current limit
    let remaining_limit = initial_uncollateralized_loan_limit - initial_borrow_amount;
    let exceeding_limit = remaining_limit + Uint128::from(100_u64);

    block_time += 1000_u64;
    let borrow_msg = ExecuteMsg::Borrow {
        denom: "somecoin".to_string(),
        amount: exceeding_limit,
        recipient: None,
    };
    let borrow_env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    let error_res = execute(deps.as_mut(), borrow_env, info, borrow_msg).unwrap_err();
    assert_eq!(error_res, ContractError::BorrowAmountExceedsUncollateralizedLoanLimit {});

    // Borrow a valid amount given uncollateralized loan limit
    block_time += 1000_u64;
    let borrow_msg = ExecuteMsg::Borrow {
        denom: "somecoin".to_string(),
        amount: remaining_limit - Uint128::from(20_u128),
        recipient: None,
    };
    let borrow_env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    execute(deps.as_mut(), borrow_env, info, borrow_msg).unwrap();

    // Set limit to zero
    let update_allowance_msg = ExecuteMsg::UpdateUncollateralizedLoanLimit {
        user: borrower_addr.to_string(),
        denom: "somecoin".to_string(),
        new_limit: Uint128::zero(),
    };
    let allowance_env = mock_env_at_block_time(block_time);
    let info = mock_info("owner", &[]);
    execute(deps.as_mut(), allowance_env, info, update_allowance_msg).unwrap();

    // check user's allowance is zero
    let allowance =
        UNCOLLATERALIZED_LOAN_LIMITS.load(&deps.storage, (&borrower_addr, "somecoin")).unwrap();
    assert_eq!(allowance, Uint128::zero());

    // check user's uncollateralized debt flag is false (limit == 0)
    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "somecoin")).unwrap();
    assert!(!debt.uncollateralized);
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)      | `String`       | Address that receives the credit       |
| [`denom`](focus://json#4)      | `String`       | Asset the user receives the credit in       |
| [`new_limit`](focus://json#5)      | `Uint128`       | Limit for the uncolateralize loan       |

</CH.Section>

### `deposit`

Deposits native coins. Deposited coins must be sent in the transaction this call is made.

<CH.Section>

<CH.Code>

```json json
{
    "deposit": {
        "on_behalf_of": "..."
    }
}
```

```rust msg.rs focus=1:3,20:22,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,28:33,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn deposit(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    on_behalf_of: Option<String>,
    denom: String,
    deposit_amount: Uint128,
) -> Result<Response, ContractError> {
    let user_addr: Addr;
    let user = if let Some(address) = on_behalf_of {
        user_addr = deps.api.addr_validate(&address)?;
        User(&user_addr)
    } else {
        User(&info.sender)
    };

    let mut market = MARKETS.load(deps.storage, &denom)?;
    if !market.deposit_enabled {
        return Err(ContractError::DepositNotEnabled {
            denom,
        });
    }

    let total_scaled_deposits = market.collateral_total_scaled;
    let total_deposits =
        get_underlying_liquidity_amount(total_scaled_deposits, &market, env.block.time.seconds())?;
    if total_deposits.checked_add(deposit_amount)? > market.deposit_cap {
        return Err(ContractError::DepositCapExceeded {
            denom,
        });
    }

    let mut response = Response::new();

    let config = CONFIG.load(deps.storage)?;

    // update indexes and interest rates
    let addresses = address_provider::helpers::query_addresses(
        deps.as_ref(),
        &config.address_provider,
        vec![MarsAddressType::Incentives, MarsAddressType::RewardsCollector],
    )?;
    let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
    let incentives_addr = &addresses[&MarsAddressType::Incentives];

    response = apply_accumulated_interests(
        deps.storage,
        &env,
        &mut market,
        rewards_collector_addr,
        incentives_addr,
        response,
    )?;

    response = update_interest_rates(&deps, &env, &mut market, Uint128::zero(), &denom, response)?;

    if market.liquidity_index.is_zero() {
        return Err(ContractError::InvalidLiquidityIndex {});
    }
    let deposit_amount_scaled =
        get_scaled_liquidity_amount(deposit_amount, &market, env.block.time.seconds())?;

    response = user.increase_collateral(
        deps.storage,
        &market,
        deposit_amount_scaled,
        incentives_addr,
        response,
    )?;

    market.increase_collateral(deposit_amount_scaled)?;
    MARKETS.save(deps.storage, &denom, &market)?;

    Ok(response
        .add_attribute("action", "outposts/red-bank/deposit")
        .add_attribute("sender", &info.sender)
        .add_attribute("on_behalf_of", user)
        .add_attribute("denom", denom)
        .add_attribute("amount", deposit_amount)
        .add_attribute("amount_scaled", deposit_amount_scaled))
}
```

```rust test
#[test]
fn depositing_with_no_coin_sent() {
    let TestSuite {
        mut deps,
        depositor_addr,
        ..
    } = setup_test();

    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info(depositor_addr.as_str(), &[]),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap_err();
    assert_eq!(err, PaymentError::NoFunds {}.into());
}

#[test]
fn depositing_with_multiple_coins_sent() {
    let TestSuite {
        mut deps,
        depositor_addr,
        ..
    } = setup_test();

    let sent_coins = vec![coin(123, "uatom"), coin(456, "uosmo")];

    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info(depositor_addr.as_str(), &sent_coins),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap_err();
    assert_eq!(err, PaymentError::MultipleDenoms {}.into());
}

#[test]
fn depositing_to_non_existent_market() {
    let TestSuite {
        mut deps,
        depositor_addr,
        ..
    } = setup_test();

    // there isn't a market for this denom
    let false_denom = "usteak";

    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info(depositor_addr.as_str(), &coins(123, false_denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap_err();
    assert_eq!(err, StdError::not_found(type_name::<Market>()).into());
}

#[test]
fn depositing_to_disabled_market() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        ..
    } = setup_test();

    // disable the market
    MARKETS
        .update(deps.as_mut().storage, denom, |opt| -> StdResult<_> {
            let mut market = opt.unwrap();
            market.deposit_enabled = false;
            Ok(market)
        })
        .unwrap();

    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info(depositor_addr.as_str(), &coins(123, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap_err();
    assert_eq!(
        err,
        ContractError::DepositNotEnabled {
            denom: denom.to_string(),
        }
    );
}

#[test]
fn depositing_above_cap() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        ..
    } = setup_test();

    // set a deposit cap
    MARKETS
        .update(deps.as_mut().storage, denom, |opt| -> StdResult<_> {
            let mut market = opt.unwrap();
            market.collateral_total_scaled = Uint128::new(9_000_000) * SCALING_FACTOR;
            market.deposit_cap = Uint128::new(10_000_000);
            Ok(market)
        })
        .unwrap();

    // try deposit with a big amount, should fail
    let err = execute(
        deps.as_mut(),
        mock_env_at_block_time(10000100),
        mock_info(depositor_addr.as_str(), &coins(1_000_001, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap_err();
    assert_eq!(
        err,
        ContractError::DepositCapExceeded {
            denom: denom.to_string()
        }
    );

    // deposit a smaller amount, should work
    let result = execute(
        deps.as_mut(),
        mock_env_at_block_time(10000100),
        mock_info(depositor_addr.as_str(), &coins(123, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    );
    assert!(result.is_ok());
}

#[test]
fn depositing_without_existing_position() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    let block_time = 10000100;
    let deposit_amount = 110000;

    // compute expected market parameters
    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        Default::default(),
    );
    let expected_mint_amount = compute_scaled_amount(
        Uint128::from(deposit_amount),
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(depositor_addr.as_str(), &coins(deposit_amount, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap();

    // NOTE: For this particular test, the borrow interest accrued was so low that the accrued
    // protocol reward is rounded down to zero. Therefore we don't expect a message to update the
    // index of the reward collector.
    assert_eq!(
        res.messages,
        vec![SubMsg::new(WasmMsg::Execute {
            contract_addr: MarsAddressType::Incentives.to_string(),
            msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                user_addr: depositor_addr.clone(),
                denom: initial_market.denom.clone(),
                user_amount_scaled_before: Uint128::zero(),
                // NOTE: Protocol rewards accrued is zero, so here it's initial total supply
                total_amount_scaled_before: initial_market.collateral_total_scaled,
            })
            .unwrap(),
            funds: vec![]
        })]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/deposit"),
            attr("sender", &depositor_addr),
            attr("on_behalf_of", &depositor_addr),
            attr("denom", denom),
            attr("amount", deposit_amount.to_string()),
            attr("amount_scaled", expected_mint_amount),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event(denom, &expected_params)]);

    // indexes and interest rates should have been updated
    let market = MARKETS.load(deps.as_ref().storage, denom).unwrap();
    assert_eq!(market.borrow_index, expected_params.borrow_index);
    assert_eq!(market.liquidity_index, expected_params.liquidity_index);
    assert_eq!(market.borrow_rate, expected_params.borrow_rate);
    assert_eq!(market.liquidity_rate, expected_params.liquidity_rate);

    // total collateral amount should have been updated
    let expected = initial_market.collateral_total_scaled + expected_mint_amount;
    assert_eq!(market.collateral_total_scaled, expected);

    // the depositor previously did not have a collateral position
    // a position should have been created with the correct scaled amount, and enabled by default
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&depositor_addr, denom)).unwrap();
    assert_eq!(
        collateral,
        Collateral {
            amount_scaled: expected_mint_amount,
            enabled: true
        }
    );
}

#[test]
fn depositing_with_existing_position() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    // create a collateral position for the user, with the `enabled` parameter as false
    let collateral_amount_scaled = Uint128::new(123456);
    set_collateral(deps.as_mut(), &depositor_addr, denom, collateral_amount_scaled, false);

    let block_time = 10000100;
    let deposit_amount = 110000;

    // compute expected market parameters
    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        Default::default(),
    );
    let expected_mint_amount = compute_scaled_amount(
        Uint128::from(deposit_amount),
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(depositor_addr.as_str(), &coins(deposit_amount, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap();

    // NOTE: For this particular test, the borrow interest accrued was so low that the accrued
    // protocol reward is rounded down to zero. Therefore we don't expect a message to update the
    // index of the reward collector.
    assert_eq!(
        res.messages,
        vec![SubMsg::new(WasmMsg::Execute {
            contract_addr: MarsAddressType::Incentives.to_string(),
            msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                user_addr: depositor_addr.clone(),
                denom: initial_market.denom.clone(),
                user_amount_scaled_before: collateral_amount_scaled,
                // NOTE: Protocol rewards accrued is zero, so here it's initial total supply
                total_amount_scaled_before: initial_market.collateral_total_scaled,
            })
            .unwrap(),
            funds: vec![]
        })]
    );

    // the depositor's scaled collateral amount should have been increased
    // however, the `enabled` status should not been affected
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&depositor_addr, denom)).unwrap();
    let expected = collateral_amount_scaled + expected_mint_amount;
    assert_eq!(
        collateral,
        Collateral {
            amount_scaled: expected,
            enabled: false
        }
    );
}

#[test]
fn depositing_on_behalf_of() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    let deposit_amount = 123456u128;
    let on_behalf_of_addr = Addr::unchecked("jake");

    // compute expected market parameters
    let block_time = 10000300;
    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        Default::default(),
    );
    let expected_mint_amount = compute_scaled_amount(
        Uint128::from(deposit_amount),
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();
    let expected_reward_amount_scaled = compute_scaled_amount(
        expected_params.protocol_rewards_to_distribute,
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(depositor_addr.as_str(), &coins(deposit_amount, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: Some(on_behalf_of_addr.clone().into()),
        },
    )
    .unwrap();

    // NOTE: For this test, the accrued protocol reward is non-zero, so we do expect a message to
    // update the index of the rewards collector.
    assert_eq!(
        res.messages,
        vec![
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: Addr::unchecked(MarsAddressType::RewardsCollector.to_string()),
                    denom: initial_market.denom.clone(),
                    user_amount_scaled_before: Uint128::zero(),
                    total_amount_scaled_before: initial_market.collateral_total_scaled,
                })
                .unwrap(),
                funds: vec![]
            }),
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: on_behalf_of_addr.clone(),
                    denom: initial_market.denom.clone(),
                    user_amount_scaled_before: Uint128::zero(),
                    // NOTE: New collateral shares were minted to the rewards collector first, so
                    // for the depositor this should be initial total supply + rewards shares minted
                    total_amount_scaled_before: initial_market.collateral_total_scaled
                        + expected_reward_amount_scaled,
                })
                .unwrap(),
                funds: vec![]
            })
        ]
    );

    // depositor should not have created a new collateral position
    let opt = COLLATERALS.may_load(deps.as_ref().storage, (&depositor_addr, denom)).unwrap();
    assert!(opt.is_none());

    // the recipient should have created a new collateral position
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&on_behalf_of_addr, denom)).unwrap();
    assert_eq!(
        collateral,
        Collateral {
            amount_scaled: expected_mint_amount,
            enabled: true,
        }
    );
}

#[test]
fn depositing_on_behalf_of_cannot_enable_collateral() {
    let TestSuite {
        mut deps,
        denom,
        depositor_addr,
        ..
    } = setup_test();

    deps.querier.set_oracle_price(denom, Decimal::one());

    let on_behalf_of_addr = Addr::unchecked("jake");

    let block_time = 10000300;

    // 'on_behalf_of_addr' deposit funds to their own account
    execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(on_behalf_of_addr.as_str(), &coins(1u128, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: None,
        },
    )
    .unwrap();

    // 'on_behalf_of_addr' should have collateral enabled
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&on_behalf_of_addr, denom)).unwrap();
    assert!(collateral.enabled);

    // 'on_behalf_of_addr' disables asset as collateral
    execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(on_behalf_of_addr.as_str(), &[]),
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom: denom.to_string(),
            enable: false,
        },
    )
    .unwrap();

    // verify asset is disabled as collateral for 'on_behalf_of_addr'
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&on_behalf_of_addr, denom)).unwrap();
    assert!(!collateral.enabled);

    // 'depositor_addr' deposits a small amount of funds to 'on_behalf_of_addr' to enable his asset as collateral
    execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(depositor_addr.as_str(), &coins(1u128, denom)),
        ExecuteMsg::Deposit {
            on_behalf_of: Some(on_behalf_of_addr.to_string()),
        },
    )
    .unwrap();

    // 'on_behalf_of_addr' doesn't have the asset enabled as collateral
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&on_behalf_of_addr, denom)).unwrap();
    assert!(!collateral.enabled);
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`on_behalf_of`](focus://json#3)      | `Option<String>`       | Address that will receive deposited tokens       |

</CH.Section>

<img src={RedBankDepositUrl} />

### `withdraw`

Withdraws an amount of the asset burning an equivalent amount deposited tokens.

<CH.Section>
<CH.Code>

```json json
{
    "withdraw": {
        "denom": "...", 
        "amount": 123, 
        "recipient": "..."
    }
}
```

```rust msg.rs focus=1:3,23:27,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,34:38,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn withdraw(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    amount: Option<Uint128>,
    recipient: Option<String>,
) -> Result<Response, ContractError> {
    let withdrawer = User(&info.sender);

    let mut market = MARKETS.load(deps.storage, &denom)?;

    let collateral = withdrawer.collateral(deps.storage, &denom)?;
    let withdrawer_balance_scaled_before = collateral.amount_scaled;

    if withdrawer_balance_scaled_before.is_zero() {
        return Err(ContractError::UserNoCollateralBalance {
            user: withdrawer.into(),
            denom,
        });
    }

    let withdrawer_balance_before = get_underlying_liquidity_amount(
        withdrawer_balance_scaled_before,
        &market,
        env.block.time.seconds(),
    )?;

    let withdraw_amount = match amount {
        Some(amount) => {
            // Check user has sufficient balance to send back
            if amount.is_zero() || amount > withdrawer_balance_before {
                return Err(ContractError::InvalidWithdrawAmount {
                    denom,
                });
            };
            amount
        }
        None => {
            // If no amount is specified, the full balance is withdrawn
            withdrawer_balance_before
        }
    };

    let config = CONFIG.load(deps.storage)?;

    let addresses = address_provider::helpers::query_addresses(
        deps.as_ref(),
        &config.address_provider,
        vec![
            MarsAddressType::Oracle,
            MarsAddressType::Incentives,
            MarsAddressType::RewardsCollector,
        ],
    )?;
    let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
    let incentives_addr = &addresses[&MarsAddressType::Incentives];
    let oracle_addr = &addresses[&MarsAddressType::Oracle];

    // if asset is used as collateral and user is borrowing we need to validate health factor after withdraw,
    // otherwise no reasons to block the withdraw
    if collateral.enabled
        && withdrawer.is_borrowing(deps.storage)
        && !assert_below_liq_threshold_after_withdraw(
            &deps.as_ref(),
            &env,
            withdrawer.address(),
            oracle_addr,
            &denom,
            withdraw_amount,
        )?
    {
        return Err(ContractError::InvalidHealthFactorAfterWithdraw {});
    }

    let mut response = Response::new();

    // update indexes and interest rates
    response = apply_accumulated_interests(
        deps.storage,
        &env,
        &mut market,
        rewards_collector_addr,
        incentives_addr,
        response,
    )?;

    response = update_interest_rates(&deps, &env, &mut market, withdraw_amount, &denom, response)?;

    // reduce the withdrawer's scaled collateral amount
    let withdrawer_balance_after = withdrawer_balance_before.checked_sub(withdraw_amount)?;
    let withdrawer_balance_scaled_after =
        get_scaled_liquidity_amount(withdrawer_balance_after, &market, env.block.time.seconds())?;

    let withdraw_amount_scaled =
        withdrawer_balance_scaled_before.checked_sub(withdrawer_balance_scaled_after)?;

    response = withdrawer.decrease_collateral(
        deps.storage,
        &market,
        withdraw_amount_scaled,
        incentives_addr,
        response,
    )?;

    market.decrease_collateral(withdraw_amount_scaled)?;
    MARKETS.save(deps.storage, &denom, &market)?;

    // send underlying asset to user or another recipient
    let recipient_addr = if let Some(recipient) = recipient {
        deps.api.addr_validate(&recipient)?
    } else {
        withdrawer.address().clone()
    };

    Ok(response
        .add_message(build_send_asset_msg(&recipient_addr, &denom, withdraw_amount))
        .add_attribute("action", "outposts/red-bank/withdraw")
        .add_attribute("sender", withdrawer)
        .add_attribute("recipient", recipient_addr)
        .add_attribute("denom", denom)
        .add_attribute("amount", withdraw_amount)
        .add_attribute("amount_scaled", withdraw_amount_scaled))
}
```

```rust test
#[test]
fn withdrawing_more_than_balance() {
    let TestSuite {
        mut deps,
        denom,
        withdrawer_addr,
        ..
    } = setup_test();

    // give withdrawer a small collateral position
    set_collateral(deps.as_mut(), &withdrawer_addr, denom, Uint128::new(200), false);

    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denom.to_string(),
            amount: Some(Uint128::from(2000u128)),
            recipient: None,
        },
    )
    .unwrap_err();
    assert_eq!(
        err,
        ContractError::InvalidWithdrawAmount {
            denom: denom.to_string()
        }
    );
}

#[test]
fn withdrawing_partially() {
    let TestSuite {
        mut deps,
        denom,
        withdrawer_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    let block_time = initial_market.indexes_last_updated + 2000;
    let withdraw_amount = Uint128::new(20_000);

    // create a collateral position for the user
    // for this test, we assume the user has NOT enabled the asset as collateral
    // the health factor check should have been skipped (no need to set mock oracle price)
    let initial_deposit_amount_scaled = initial_market.collateral_total_scaled;
    set_collateral(
        deps.as_mut(),
        &withdrawer_addr,
        &initial_market.denom,
        initial_deposit_amount_scaled,
        false,
    );

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denom.to_string(),
            amount: Some(withdraw_amount),
            recipient: None,
        },
    )
    .unwrap();

    let market = MARKETS.load(deps.as_ref().storage, denom).unwrap();

    // compute expected market parameters
    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        TestUtilizationDeltaInfo {
            less_liquidity: withdraw_amount,
            ..Default::default()
        },
    );

    let expected_deposit_balance = compute_underlying_amount(
        initial_deposit_amount_scaled,
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_withdraw_amount_remaining = expected_deposit_balance - withdraw_amount;

    let expected_withdraw_amount_scaled_remaining = compute_scaled_amount(
        expected_withdraw_amount_remaining,
        expected_params.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_burn_amount =
        initial_deposit_amount_scaled - expected_withdraw_amount_scaled_remaining;

    let expected_rewards_amount_scaled = compute_scaled_amount(
        expected_params.protocol_rewards_to_distribute,
        market.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_total_collateral_amount_scaled = initial_market.collateral_total_scaled
        - expected_burn_amount
        + expected_rewards_amount_scaled;

    assert_eq!(
        res.messages,
        vec![
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: Addr::unchecked(MarsAddressType::RewardsCollector.to_string()),
                    denom: denom.to_string(),
                    user_amount_scaled_before: Uint128::zero(),
                    total_amount_scaled_before: initial_market.collateral_total_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: withdrawer_addr.clone(),
                    denom: denom.to_string(),
                    user_amount_scaled_before: initial_deposit_amount_scaled,
                    total_amount_scaled_before: initial_market.collateral_total_scaled
                        + expected_rewards_amount_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(BankMsg::Send {
                to_address: withdrawer_addr.to_string(),
                amount: coins(withdraw_amount.u128(), denom)
            })
        ]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/withdraw"),
            attr("sender", &withdrawer_addr),
            attr("recipient", &withdrawer_addr),
            attr("denom", denom),
            attr("amount", withdraw_amount),
            attr("amount_scaled", expected_burn_amount),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event(denom, &expected_params)]);

    // market parameters should have been updated
    assert_eq!(market.borrow_index, expected_params.borrow_index);
    assert_eq!(market.liquidity_index, expected_params.liquidity_index);
    assert_eq!(market.borrow_rate, expected_params.borrow_rate);
    assert_eq!(market.liquidity_rate, expected_params.liquidity_rate);

    // the market's total collateral scaled amount should have been decreased
    assert_eq!(market.collateral_total_scaled, expected_total_collateral_amount_scaled);

    // the user's collateral scaled amount should have been decreased
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&withdrawer_addr, denom)).unwrap();
    assert_eq!(collateral.amount_scaled, expected_withdraw_amount_scaled_remaining);

    // the reward collector's collateral scaled amount should have been increased
    let rewards_addr = Addr::unchecked(MarsAddressType::RewardsCollector.to_string());
    let collateral = COLLATERALS.load(deps.as_ref().storage, (&rewards_addr, denom)).unwrap();
    assert_eq!(collateral.amount_scaled, expected_rewards_amount_scaled);
}

#[test]
fn withdrawing_completely() {
    let TestSuite {
        mut deps,
        denom,
        withdrawer_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    let block_time = initial_market.indexes_last_updated + 2000;

    // create a collateral position for the withdrawer
    let withdrawer_balance_scaled = Uint128::new(123_456) * SCALING_FACTOR;
    set_collateral(deps.as_mut(), &withdrawer_addr, denom, withdrawer_balance_scaled, true);

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denom.to_string(),
            amount: None,
            recipient: None,
        },
    )
    .unwrap();

    let market = MARKETS.load(&deps.storage, denom).unwrap();

    let withdrawer_balance = compute_underlying_amount(
        withdrawer_balance_scaled,
        get_updated_liquidity_index(&initial_market, block_time).unwrap(),
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        TestUtilizationDeltaInfo {
            less_liquidity: withdrawer_balance,
            ..Default::default()
        },
    );

    let expected_rewards_amount_scaled = compute_scaled_amount(
        expected_params.protocol_rewards_to_distribute,
        market.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    assert_eq!(
        res.messages,
        vec![
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: Addr::unchecked(MarsAddressType::RewardsCollector.to_string()),
                    denom: denom.to_string(),
                    user_amount_scaled_before: Uint128::zero(),
                    total_amount_scaled_before: initial_market.collateral_total_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: withdrawer_addr.clone(),
                    denom: denom.to_string(),
                    user_amount_scaled_before: withdrawer_balance_scaled,
                    total_amount_scaled_before: initial_market.collateral_total_scaled
                        + expected_rewards_amount_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
                to_address: withdrawer_addr.to_string(),
                amount: coins(withdrawer_balance.u128(), denom)
            })),
        ]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/withdraw"),
            attr("sender", &withdrawer_addr),
            attr("recipient", &withdrawer_addr),
            attr("denom", denom),
            attr("amount", withdrawer_balance.to_string()),
            attr("amount_scaled", withdrawer_balance_scaled.to_string()),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event(denom, &expected_params)]);

    assert_eq!(market.borrow_index, expected_params.borrow_index);
    assert_eq!(market.liquidity_index, expected_params.liquidity_index);
    assert_eq!(market.borrow_rate, expected_params.borrow_rate);
    assert_eq!(market.liquidity_rate, expected_params.liquidity_rate);

    // withdrawer's collateral position should have been deleted after full withdraw
    assert!(!has_collateral_position(deps.as_ref(), &withdrawer_addr, denom));
}

#[test]
fn withdrawing_to_another_user() {
    let TestSuite {
        mut deps,
        denom,
        withdrawer_addr,
        initial_market,
        initial_liquidity,
    } = setup_test();

    let block_time = initial_market.indexes_last_updated + 2000;
    let recipient_addr = Addr::unchecked("jake");

    // create a collateral position for the withdrawer
    let withdrawer_balance_scaled = Uint128::new(123_456) * SCALING_FACTOR;
    set_collateral(deps.as_mut(), &withdrawer_addr, denom, withdrawer_balance_scaled, true);

    let res = execute(
        deps.as_mut(),
        mock_env_at_block_time(block_time),
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denom.to_string(),
            amount: None,
            recipient: Some(recipient_addr.to_string()),
        },
    )
    .unwrap();

    let market = MARKETS.load(deps.as_ref().storage, denom).unwrap();

    let withdraw_amount = compute_underlying_amount(
        withdrawer_balance_scaled,
        market.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_params = th_get_expected_indices_and_rates(
        &initial_market,
        block_time,
        initial_liquidity,
        TestUtilizationDeltaInfo {
            less_liquidity: withdraw_amount,
            ..Default::default()
        },
    );

    let expected_rewards_amount_scaled = compute_scaled_amount(
        expected_params.protocol_rewards_to_distribute,
        market.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    // check if the withdrew funds are properly sent to the designated recipient
    assert_eq!(
        res.messages,
        vec![
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: Addr::unchecked(MarsAddressType::RewardsCollector.to_string()),
                    denom: denom.to_string(),
                    user_amount_scaled_before: Uint128::zero(),
                    total_amount_scaled_before: initial_market.collateral_total_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: withdrawer_addr.clone(),
                    denom: denom.to_string(),
                    user_amount_scaled_before: withdrawer_balance_scaled,
                    total_amount_scaled_before: initial_market.collateral_total_scaled
                        + expected_rewards_amount_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
                to_address: recipient_addr.to_string(),
                amount: coins(withdraw_amount.u128(), denom)
            }))
        ]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/withdraw"),
            attr("sender", &withdrawer_addr),
            attr("recipient", &recipient_addr),
            attr("denom", denom.to_string()),
            attr("amount", withdraw_amount.to_string()),
            attr("amount_scaled", withdrawer_balance_scaled.to_string()),
        ]
    );

    // withdrawer's collateral position should have been deleted after full withdraw
    assert!(!has_collateral_position(deps.as_ref(), &withdrawer_addr, denom));
}

struct HealthCheckTestSuite {
    deps: OwnedDeps<MockStorage, MockApi, MarsMockQuerier>,
    denoms: [&'static str; 3],
    markets: [Market; 3],
    prices: [Decimal; 3],
    collaterals: [Collateral; 3],
    debts: [Debt; 3],
    withdrawer_addr: Addr,
}

fn setup_health_check_test() -> HealthCheckTestSuite {
    let denoms = ["uatom", "uosmo", "umars"];
    let initial_liquidity = Uint128::from(10000000u128);

    let mut deps = th_setup(&[coin(initial_liquidity.into(), denoms[2])]);

    let withdrawer_addr = Addr::unchecked("withdrawer");

    let markets = [
        Market {
            denom: denoms[0].to_string(),
            liquidity_index: Decimal::one(),
            borrow_index: Decimal::one(),
            max_loan_to_value: Decimal::from_ratio(40u128, 100u128),
            liquidation_threshold: Decimal::from_ratio(60u128, 100u128),
            collateral_total_scaled: Uint128::new(100_000) * SCALING_FACTOR,
            ..Default::default()
        },
        Market {
            denom: denoms[1].to_string(),
            liquidity_index: Decimal::one(),
            borrow_index: Decimal::one(),
            max_loan_to_value: Decimal::from_ratio(50u128, 100u128),
            liquidation_threshold: Decimal::from_ratio(80u128, 100u128),
            collateral_total_scaled: Uint128::new(100_000) * SCALING_FACTOR,
            ..Default::default()
        },
        Market {
            denom: denoms[2].to_string(),
            liquidity_index: Decimal::one(),
            borrow_index: Decimal::one(),
            max_loan_to_value: Decimal::from_ratio(20u128, 100u128),
            liquidation_threshold: Decimal::from_ratio(40u128, 100u128),
            collateral_total_scaled: Uint128::new(100_000) * SCALING_FACTOR,
            ..Default::default()
        },
    ];

    let prices = [
        Decimal::from_ratio(3u128, 1u128),
        Decimal::from_ratio(2u128, 1u128),
        Decimal::from_ratio(1u128, 1u128),
    ];

    let collaterals = [
        Collateral {
            amount_scaled: Uint128::new(100_000) * SCALING_FACTOR,
            enabled: true,
        },
        Collateral {
            amount_scaled: Uint128::zero(),
            enabled: false,
        },
        Collateral {
            amount_scaled: Uint128::new(600_000) * SCALING_FACTOR,
            enabled: true,
        },
    ];

    let debts = [
        Debt {
            amount_scaled: Uint128::zero(),
            uncollateralized: false,
        },
        Debt {
            amount_scaled: Uint128::new(200_000) * SCALING_FACTOR,
            uncollateralized: false,
        },
        Debt {
            amount_scaled: Uint128::new(200_000) * SCALING_FACTOR,
            uncollateralized: true,
        },
    ];

    denoms
        .iter()
        .zip(markets.iter())
        .try_for_each(|(denom, market)| MARKETS.save(deps.as_mut().storage, denom, market))
        .unwrap();

    denoms
        .iter()
        .zip(prices.iter())
        .for_each(|(denom, price)| deps.querier.set_oracle_price(denom, *price));

    denoms.iter().zip(collaterals.iter()).for_each(|(denom, collateral)| {
        if !collateral.amount_scaled.is_zero() {
            COLLATERALS.save(deps.as_mut().storage, (&withdrawer_addr, denom), collateral).unwrap();
        }
    });

    denoms.iter().zip(debts.iter()).for_each(|(denom, debt)| {
        if !debt.amount_scaled.is_zero() {
            DEBTS.save(deps.as_mut().storage, (&withdrawer_addr, denom), debt).unwrap();
        }
    });

    HealthCheckTestSuite {
        deps,
        denoms,
        markets,
        prices,
        collaterals,
        debts,
        withdrawer_addr,
    }
}

/// Calculate how much to withdraw to have health factor equal to one
fn how_much_to_withdraw(suite: &HealthCheckTestSuite, block_time: u64) -> Uint128 {
    let HealthCheckTestSuite {
        markets,
        prices,
        collaterals,
        debts,
        ..
    } = suite;

    let token_1_weighted_lt_in_base_asset = compute_underlying_amount(
        collaterals[0].amount_scaled,
        get_updated_liquidity_index(&markets[0], block_time).unwrap(),
        ScalingOperation::Truncate,
    )
    .unwrap()
        * markets[0].liquidation_threshold
        * prices[0];

    let token_3_weighted_lt_in_base_asset = compute_underlying_amount(
        collaterals[2].amount_scaled,
        get_updated_liquidity_index(&markets[2], block_time).unwrap(),
        ScalingOperation::Truncate,
    )
    .unwrap()
        * markets[2].liquidation_threshold
        * prices[2];

    let weighted_liquidation_threshold_in_base_asset =
        token_1_weighted_lt_in_base_asset + token_3_weighted_lt_in_base_asset;

    let total_collateralized_debt_in_base_asset = compute_underlying_amount(
        debts[1].amount_scaled,
        get_updated_borrow_index(&markets[1], block_time).unwrap(),
        ScalingOperation::Ceil,
    )
    .unwrap()
        * prices[1];

    // How much to withdraw in base asset to have health factor equal to one
    let how_much_to_withdraw_in_base_asset = math::divide_uint128_by_decimal(
        weighted_liquidation_threshold_in_base_asset - total_collateralized_debt_in_base_asset,
        markets[2].liquidation_threshold,
    )
    .unwrap();

    math::divide_uint128_by_decimal(how_much_to_withdraw_in_base_asset, prices[2]).unwrap()
}

#[test]
fn withdrawing_if_health_factor_not_met() {
    let suite = setup_health_check_test();

    let env = mock_env();
    let block_time = env.block.time.seconds();

    let max_withdraw_amount = how_much_to_withdraw(&suite, block_time);

    let HealthCheckTestSuite {
        mut deps,
        denoms,
        withdrawer_addr,
        ..
    } = suite;

    // withdraw token3 with failure
    // the withdraw amount needs to be a little bit greater to have health factor less than one
    let withdraw_amount = max_withdraw_amount + Uint128::from(10u128);

    let err = execute(
        deps.as_mut(),
        env,
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denoms[2].to_string(),
            amount: Some(withdraw_amount),
            recipient: None,
        },
    )
    .unwrap_err();
    assert_eq!(err, ContractError::InvalidHealthFactorAfterWithdraw {});
}

#[test]
fn withdrawing_if_health_factor_met() {
    let suite = setup_health_check_test();

    let env = mock_env();
    let block_time = env.block.time.seconds();

    let max_withdraw_amount = how_much_to_withdraw(&suite, block_time);

    let HealthCheckTestSuite {
        mut deps,
        denoms,
        markets,
        collaterals,
        withdrawer_addr,
        ..
    } = suite;

    // withdraw token3 with success
    // the withdraw amount needs to be a little bit smaller to have health factor greater than one
    let withdraw_amount = max_withdraw_amount - Uint128::from(10u128);

    let res = execute(
        deps.as_mut(),
        env,
        mock_info(withdrawer_addr.as_str(), &[]),
        ExecuteMsg::Withdraw {
            denom: denoms[2].to_string(),
            amount: Some(withdraw_amount),
            recipient: None,
        },
    )
    .unwrap();

    // NOTE: For this particular test, we have set the borrow interest rate at zero, so there no
    // protocol reward accrued, and hence no message to update the reward collector's index at the
    // incentives contract.
    assert_eq!(
        res.messages,
        vec![
            SubMsg::new(WasmMsg::Execute {
                contract_addr: MarsAddressType::Incentives.to_string(),
                msg: to_binary(&incentives::ExecuteMsg::BalanceChange {
                    user_addr: withdrawer_addr.clone(),
                    denom: denoms[2].to_string(),
                    user_amount_scaled_before: collaterals[2].amount_scaled,
                    // NOTE: Protocol rewards accrued is zero, so here it's initial total supply
                    total_amount_scaled_before: markets[2].collateral_total_scaled,
                })
                .unwrap(),
                funds: vec![],
            }),
            SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
                to_address: withdrawer_addr.to_string(),
                amount: coins(withdraw_amount.u128(), denoms[2])
            }))
        ],
    );

    let expected_withdraw_amount_scaled =
        get_scaled_liquidity_amount(withdraw_amount, &markets[2], block_time).unwrap();
    let expected_withdrawer_balance_after =
        collaterals[2].amount_scaled - expected_withdraw_amount_scaled;
    let expected_collateral_total_amount_scaled_after =
        markets[2].collateral_total_scaled - expected_withdraw_amount_scaled;

    let col = COLLATERALS.load(deps.as_ref().storage, (&withdrawer_addr, denoms[2])).unwrap();
    assert_eq!(col.amount_scaled, expected_withdrawer_balance_after);

    let market = MARKETS.load(deps.as_ref().storage, denoms[2]).unwrap();
    assert_eq!(market.collateral_total_scaled, expected_collateral_total_amount_scaled_after);
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)      | `String`       | Asset to withdraw       |
| [`amount`](focus://json#4)      | `Option<Uint128>`       | Amount to be withdrawn. If None is specified, the full amount will be withdrawn       |
| [`recipient`](focus://json#5)      | `Option<String>`       | The address where the withdrawn amount is sent       |

</CH.Section>

<img src={RedBankWithdrawUrl} />

### `borrow`

Borrows native coins. If borrow allowed, amount is added to caller's debt and sent to the address.

<CH.Section>
<CH.Code>

```json json
{
    "borrow": {
        "denom": "...", 
        "amount": 123, 
        "recipient" "mars..."
    }
}
```

```rust msg.rs focus=1:3,28:32,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,39:43,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn borrow(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    borrow_amount: Uint128,
    recipient: Option<String>,
) -> Result<Response, ContractError> {
    let borrower = User(&info.sender);

    // Cannot borrow zero amount
    if borrow_amount.is_zero() {
        return Err(ContractError::InvalidBorrowAmount {
            denom,
        });
    }

    // Load market and user state
    let mut borrow_market = MARKETS.load(deps.storage, &denom)?;

    if !borrow_market.borrow_enabled {
        return Err(ContractError::BorrowNotEnabled {
            denom,
        });
    }

    let uncollateralized_loan_limit = borrower.uncollateralized_loan_limit(deps.storage, &denom)?;

    let config = CONFIG.load(deps.storage)?;

    let addresses = address_provider::helpers::query_addresses(
        deps.as_ref(),
        &config.address_provider,
        vec![
            MarsAddressType::Oracle,
            MarsAddressType::Incentives,
            MarsAddressType::RewardsCollector,
        ],
    )?;
    let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
    let incentives_addr = &addresses[&MarsAddressType::Incentives];
    let oracle_addr = &addresses[&MarsAddressType::Oracle];

    // Check if user can borrow specified amount
    let mut uncollateralized_debt = false;
    if uncollateralized_loan_limit.is_zero() {
        if !assert_below_max_ltv_after_borrow(
            &deps.as_ref(),
            &env,
            borrower.address(),
            oracle_addr,
            &denom,
            borrow_amount,
        )? {
            return Err(ContractError::BorrowAmountExceedsGivenCollateral {});
        }
    } else {
        // Uncollateralized loan: check borrow amount plus debt does not exceed uncollateralized loan limit
        uncollateralized_debt = true;

        let debt_amount_scaled = borrower.debt_amount_scaled(deps.storage, &denom)?;

        let asset_market = MARKETS.load(deps.storage, &denom)?;
        let debt_amount = get_underlying_debt_amount(
            debt_amount_scaled,
            &asset_market,
            env.block.time.seconds(),
        )?;

        let debt_after_borrow = debt_amount.checked_add(borrow_amount)?;
        if debt_after_borrow > uncollateralized_loan_limit {
            return Err(ContractError::BorrowAmountExceedsUncollateralizedLoanLimit {});
        }
    }

    let mut response = Response::new();

    response = apply_accumulated_interests(
        deps.storage,
        &env,
        &mut borrow_market,
        rewards_collector_addr,
        incentives_addr,
        response,
    )?;

    // Set new debt
    let borrow_amount_scaled =
        get_scaled_debt_amount(borrow_amount, &borrow_market, env.block.time.seconds())?;

    borrow_market.increase_debt(borrow_amount_scaled)?;
    borrower.increase_debt(deps.storage, &denom, borrow_amount_scaled, uncollateralized_debt)?;

    response =
        update_interest_rates(&deps, &env, &mut borrow_market, borrow_amount, &denom, response)?;
    MARKETS.save(deps.storage, &denom, &borrow_market)?;

    // Send borrow amount to borrower or another recipient
    let recipient_addr = if let Some(recipient) = recipient {
        deps.api.addr_validate(&recipient)?
    } else {
        borrower.address().clone()
    };

    Ok(response
        .add_message(build_send_asset_msg(&recipient_addr, &denom, borrow_amount))
        .add_attribute("action", "outposts/red-bank/borrow")
        .add_attribute("sender", borrower)
        .add_attribute("recipient", recipient_addr)
        .add_attribute("denom", denom)
        .add_attribute("amount", borrow_amount)
        .add_attribute("amount_scaled", borrow_amount_scaled))
}
```

```rust test
#[test]
fn test_borrow_uusd() {
    let initial_liquidity = 10000000;
    let mut deps = th_setup(&[coin(initial_liquidity, "uusd")]);
    let block_time = 1;

    let borrower_addr = Addr::unchecked("borrower");
    let ltv = Decimal::from_ratio(7u128, 10u128);

    let mock_market = Market {
        liquidity_index: Decimal::one(),
        max_loan_to_value: ltv,
        borrow_index: Decimal::from_ratio(20u128, 10u128),
        borrow_rate: Decimal::one(),
        liquidity_rate: Decimal::one(),
        debt_total_scaled: Uint128::zero(),
        indexes_last_updated: block_time,
        ..Default::default()
    };
    let market = th_init_market(deps.as_mut(), "uusd", &mock_market);

    // Set user as having the market_collateral deposited
    let deposit_amount_scaled = Uint128::new(110_000) * SCALING_FACTOR;
    set_collateral(deps.as_mut(), &borrower_addr, "uusd", deposit_amount_scaled, true);

    // borrow with insufficient collateral, should fail
    let new_block_time = 120u64;
    let time_elapsed = new_block_time - market.indexes_last_updated;
    let liquidity_index = calculate_applied_linear_interest_rate(
        market.liquidity_index,
        market.liquidity_rate,
        time_elapsed,
    )
    .unwrap();
    let collateral = compute_underlying_amount(
        deposit_amount_scaled,
        liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();
    let max_to_borrow = collateral * ltv;
    let msg = ExecuteMsg::Borrow {
        denom: "uusd".to_string(),
        amount: max_to_borrow + Uint128::from(1u128),
        recipient: None,
    };
    let env = mock_env_at_block_time(new_block_time);
    let info = mock_info("borrower", &[]);
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, ContractError::BorrowAmountExceedsGivenCollateral {});

    let valid_amount = max_to_borrow - Uint128::from(1000u128);
    let msg = ExecuteMsg::Borrow {
        denom: "uusd".to_string(),
        amount: valid_amount,
        recipient: None,
    };
    let env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    execute(deps.as_mut(), env, info, msg).unwrap();

    let market_after_borrow = MARKETS.load(&deps.storage, "uusd").unwrap();

    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "uusd")).unwrap();

    assert_eq!(
        valid_amount,
        compute_underlying_amount(
            debt.amount_scaled,
            market_after_borrow.borrow_index,
            ScalingOperation::Ceil
        )
        .unwrap()
    );
}

#[test]
fn test_borrow_collateral_check() {
    // NOTE: available liquidity stays fixed as the test environment does not get changes in
    // contract balances on subsequent calls. They would change from call to call in practice
    let available_liquidity_1 = Uint128::from(1000000000u128);
    let available_liquidity_2 = Uint128::from(2000000000u128);
    let available_liquidity_3 = Uint128::from(3000000000u128);
    let mut deps = th_setup(&[
        coin(available_liquidity_1.into(), "uatom"),
        coin(available_liquidity_2.into(), "uosmo"),
        coin(available_liquidity_3.into(), "uusd"),
    ]);

    let exchange_rate_1 = Decimal::one();
    let exchange_rate_2 = Decimal::from_ratio(15u128, 4u128);
    let exchange_rate_3 = Decimal::one();

    deps.querier.set_oracle_price("uatom", exchange_rate_1);
    deps.querier.set_oracle_price("uosmo", exchange_rate_2);
    // NOTE: base asset price (asset3) should be set to 1 by the oracle helper

    let mock_market_1 = Market {
        max_loan_to_value: Decimal::from_ratio(8u128, 10u128),
        debt_total_scaled: Uint128::zero(),
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::from_ratio(1u128, 2u128),
        ..Default::default()
    };
    let mock_market_2 = Market {
        max_loan_to_value: Decimal::from_ratio(6u128, 10u128),
        debt_total_scaled: Uint128::zero(),
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::from_ratio(1u128, 2u128),
        ..Default::default()
    };
    let mock_market_3 = Market {
        max_loan_to_value: Decimal::from_ratio(4u128, 10u128),
        debt_total_scaled: Uint128::zero(),
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::from_ratio(1u128, 2u128),
        ..Default::default()
    };

    // should get index 0
    let market_1_initial = th_init_market(deps.as_mut(), "uatom", &mock_market_1);
    // should get index 1
    let market_2_initial = th_init_market(deps.as_mut(), "uosmo", &mock_market_2);
    // should get index 2
    let market_3_initial = th_init_market(deps.as_mut(), "uusd", &mock_market_3);

    let borrower_addr = Addr::unchecked("borrower");

    let balance_1 = Uint128::new(4_000_000) * SCALING_FACTOR;
    let balance_2 = Uint128::new(7_000_000) * SCALING_FACTOR;
    let balance_3 = Uint128::new(3_000_000) * SCALING_FACTOR;

    // Set user as having all the markets as collateral
    set_collateral(deps.as_mut(), &borrower_addr, &market_1_initial.denom, balance_1, true);
    set_collateral(deps.as_mut(), &borrower_addr, &market_2_initial.denom, balance_2, true);
    set_collateral(deps.as_mut(), &borrower_addr, &market_3_initial.denom, balance_3, true);

    let max_borrow_allowed_in_base_asset = (market_1_initial.max_loan_to_value
        * compute_underlying_amount(
            balance_1,
            market_1_initial.liquidity_index,
            ScalingOperation::Truncate,
        )
        .unwrap()
        * exchange_rate_1)
        + (market_2_initial.max_loan_to_value
            * compute_underlying_amount(
                balance_2,
                market_2_initial.liquidity_index,
                ScalingOperation::Truncate,
            )
            .unwrap()
            * exchange_rate_2)
        + (market_3_initial.max_loan_to_value
            * compute_underlying_amount(
                balance_3,
                market_3_initial.liquidity_index,
                ScalingOperation::Truncate,
            )
            .unwrap()
            * exchange_rate_3);
    let exceeding_borrow_amount =
        math::divide_uint128_by_decimal(max_borrow_allowed_in_base_asset, exchange_rate_2).unwrap()
            + Uint128::from(100_u64);
    let permissible_borrow_amount =
        math::divide_uint128_by_decimal(max_borrow_allowed_in_base_asset, exchange_rate_2).unwrap()
            - Uint128::from(100_u64);

    // borrow above the allowed amount given current collateral, should fail
    let borrow_msg = ExecuteMsg::Borrow {
        denom: "uosmo".to_string(),
        amount: exceeding_borrow_amount,
        recipient: None,
    };
    let env = mock_env(MockEnvParams::default());
    let info = mock_info("borrower", &[]);
    let error_res = execute(deps.as_mut(), env.clone(), info.clone(), borrow_msg).unwrap_err();
    assert_eq!(error_res, ContractError::BorrowAmountExceedsGivenCollateral {});

    // borrow permissible amount given current collateral, should succeed
    let borrow_msg = ExecuteMsg::Borrow {
        denom: "uosmo".to_string(),
        amount: permissible_borrow_amount,
        recipient: None,
    };
    execute(deps.as_mut(), env, info, borrow_msg).unwrap();
}

#[test]
fn test_cannot_borrow_if_market_not_enabled() {
    let mut deps = th_setup(&[]);

    let mock_market = Market {
        borrow_enabled: false,
        ..Default::default()
    };
    th_init_market(deps.as_mut(), "somecoin", &mock_market);

    // Check error when borrowing not allowed on market
    let env = mock_env(MockEnvParams::default());
    let info = cosmwasm_std::testing::mock_info("borrower", &[coin(110000, "somecoin")]);
    let msg = ExecuteMsg::Borrow {
        denom: "somecoin".to_string(),
        amount: Uint128::new(1000),
        recipient: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(
        error_res,
        ContractError::BorrowNotEnabled {
            denom: "somecoin".to_string()
        }
    );
}

#[test]
fn test_borrow_and_send_funds_to_another_user() {
    let initial_liquidity = 10000000;
    let mut deps = th_setup(&[coin(initial_liquidity, "uusd")]);

    let borrower_addr = Addr::unchecked("borrower");
    let another_user_addr = Addr::unchecked("another_user");

    let mock_market = Market {
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        max_loan_to_value: Decimal::from_ratio(5u128, 10u128),
        debt_total_scaled: Uint128::zero(),
        ..Default::default()
    };
    let market = th_init_market(deps.as_mut(), "uusd", &mock_market);

    // Set user as having the market_collateral deposited
    let deposit_amount_scaled = Uint128::new(100_000) * SCALING_FACTOR;
    set_collateral(deps.as_mut(), &borrower_addr, &market.denom, deposit_amount_scaled, true);

    let borrow_amount = Uint128::from(1000u128);
    let msg = ExecuteMsg::Borrow {
        denom: "uusd".to_string(),
        amount: borrow_amount,
        recipient: Some(another_user_addr.to_string()),
    };
    let env = mock_env(MockEnvParams::default());
    let info = mock_info("borrower", &[]);
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let market_after_borrow = MARKETS.load(&deps.storage, "uusd").unwrap();

    // 'borrower' has bit set for the borrowed asset of the market
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, &market.denom));

    // Debt for 'borrower' should exist
    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "uusd")).unwrap();
    assert_eq!(
        borrow_amount,
        compute_underlying_amount(
            debt.amount_scaled,
            market_after_borrow.borrow_index,
            ScalingOperation::Ceil
        )
        .unwrap()
    );

    // Debt for 'another_user' should not exist
    let debt = DEBTS.may_load(&deps.storage, (&another_user_addr, "uusd")).unwrap();
    assert!(debt.is_none());

    // Check msgs and attributes (funds should be sent to 'another_user')
    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: another_user_addr.to_string(),
            amount: coins(borrow_amount.u128(), "uusd")
        }))]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/borrow"),
            attr("sender", borrower_addr),
            attr("recipient", another_user_addr),
            attr("denom", "uusd"),
            attr("amount", borrow_amount.to_string()),
            attr("amount_scaled", borrow_amount * SCALING_FACTOR),
        ]
    );
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)      | `String`       | Asset to borrow       |
| [`amount`](focus://json#4)      | `Option<Uint128>`       | Amount to borrow       |
| [`recipient`](focus://json#5)      | `Option<String>`       | The address where the borrowed amount is sent       |

</CH.Section>

<img src={RedBankBorrowUrl} />


### `repay`

Repay native coins loan. Coins used to repay must be sent in the transaction this call is made.

<CH.Section>
<CH.Code>

```json json
{
    "repay": {
        "on_behalf_of": "..."
    }
}
```

```rust msg.rs focus=1:3,33:35,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,44:49,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn repay(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    on_behalf_of: Option<String>,
    denom: String,
    repay_amount: Uint128,
) -> Result<Response, ContractError> {
    let user_addr: Addr;
    let user = if let Some(address) = on_behalf_of {
        user_addr = deps.api.addr_validate(&address)?;
        let user = User(&user_addr);
        // Uncollateralized loans should not have 'on behalf of' because it creates accounting complexity for them
        if !user.uncollateralized_loan_limit(deps.storage, &denom)?.is_zero() {
            return Err(ContractError::CannotRepayUncollateralizedLoanOnBehalfOf {});
        }
        user
    } else {
        User(&info.sender)
    };

    // Check new debt
    let debt = DEBTS
        .may_load(deps.storage, (user.address(), &denom))?
        .ok_or(ContractError::CannotRepayZeroDebt {})?;

    let config = CONFIG.load(deps.storage)?;

    let addresses = address_provider::helpers::query_addresses(
        deps.as_ref(),
        &config.address_provider,
        vec![MarsAddressType::Incentives, MarsAddressType::RewardsCollector],
    )?;
    let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
    let incentives_addr = &addresses[&MarsAddressType::Incentives];

    let mut market = MARKETS.load(deps.storage, &denom)?;

    let mut response = Response::new();

    response = apply_accumulated_interests(
        deps.storage,
        &env,
        &mut market,
        rewards_collector_addr,
        incentives_addr,
        response,
    )?;

    let debt_amount_scaled_before = debt.amount_scaled;
    let debt_amount_before =
        get_underlying_debt_amount(debt.amount_scaled, &market, env.block.time.seconds())?;

    // If repay amount exceeds debt, refund any excess amounts
    let mut refund_amount = Uint128::zero();
    let mut debt_amount_after = Uint128::zero();
    if repay_amount > debt_amount_before {
        refund_amount = repay_amount - debt_amount_before;
        let refund_msg = build_send_asset_msg(&info.sender, &denom, refund_amount);
        response = response.add_message(refund_msg);
    } else {
        debt_amount_after = debt_amount_before - repay_amount;
    }

    let debt_amount_scaled_after =
        get_scaled_debt_amount(debt_amount_after, &market, env.block.time.seconds())?;

    let debt_amount_scaled_delta =
        debt_amount_scaled_before.checked_sub(debt_amount_scaled_after)?;

    market.decrease_debt(debt_amount_scaled_delta)?;
    user.decrease_debt(deps.storage, &denom, debt_amount_scaled_delta)?;

    response = update_interest_rates(&deps, &env, &mut market, Uint128::zero(), &denom, response)?;
    MARKETS.save(deps.storage, &denom, &market)?;

    Ok(response
        .add_attribute("action", "outposts/red-bank/repay")
        .add_attribute("sender", &info.sender)
        .add_attribute("on_behalf_of", user)
        .add_attribute("denom", denom)
        .add_attribute("amount", repay_amount.checked_sub(refund_amount)?)
        .add_attribute("amount_scaled", debt_amount_scaled_delta))
}
```

```rust test
#[test]
fn test_borrow_and_repay() {
    // consider three assets: uatom, uosmo, uusd
    // the user deposits uatom collateral, and borrow uosmo, uusd loans
    //
    // NOTE: available liquidity stays fixed as the test environment does not get changes in
    // contract balances on subsequent calls. They would change from call to call in practice
    let available_liquidity_uosmo = Uint128::new(1_000_000_000);
    let available_liquidity_uusd = Uint128::new(2_000_000_000);

    let mut deps = th_setup(&[
        coin(available_liquidity_uosmo.u128(), "uosmo"),
        coin(available_liquidity_uusd.u128(), "uusd"),
    ]);

    deps.querier.set_oracle_price("uatom", Decimal::one());
    deps.querier.set_oracle_price("uosmo", Decimal::one());
    deps.querier.set_oracle_price("uusd", Decimal::one());

    let mock_market_1 = Market {
        borrow_index: Decimal::from_ratio(12u128, 10u128),
        liquidity_index: Decimal::from_ratio(8u128, 10u128),
        borrow_rate: Decimal::from_ratio(20u128, 100u128),
        liquidity_rate: Decimal::from_ratio(10u128, 100u128),
        reserve_factor: Decimal::from_ratio(1u128, 100u128),
        debt_total_scaled: Uint128::zero(),
        indexes_last_updated: 10000000,
        ..Default::default()
    };
    let mock_market_2 = Market {
        borrow_index: Decimal::one(),
        liquidity_index: Decimal::one(),
        ..Default::default()
    };
    let mock_market_3 = Market {
        borrow_index: Decimal::one(),
        liquidity_index: Decimal::from_ratio(11u128, 10u128),
        max_loan_to_value: Decimal::from_ratio(7u128, 10u128),
        borrow_rate: Decimal::from_ratio(30u128, 100u128),
        reserve_factor: Decimal::from_ratio(3u128, 100u128),
        liquidity_rate: Decimal::from_ratio(20u128, 100u128),
        debt_total_scaled: Uint128::zero(),
        indexes_last_updated: 10000000,
        ..Default::default()
    };

    let market_1_initial = th_init_market(deps.as_mut(), "uosmo", &mock_market_1);
    let market_2_initial = th_init_market(deps.as_mut(), "uusd", &mock_market_2);
    th_init_market(deps.as_mut(), "uatom", &mock_market_3);

    let borrower_addr = Addr::unchecked("borrower");

    // Set user as having the market_collateral deposited
    set_collateral(
        deps.as_mut(),
        &borrower_addr,
        "uatom",
        Uint128::new(10000) * SCALING_FACTOR,
        true,
    );

    // *
    // Borrow uosmo
    // *
    let block_time = mock_market_1.indexes_last_updated + 10000u64;
    let borrow_amount = Uint128::from(2400u128);

    let msg = ExecuteMsg::Borrow {
        denom: "uosmo".to_string(),
        amount: borrow_amount,
        recipient: None,
    };

    let env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);

    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let expected_params_uosmo = th_get_expected_indices_and_rates(
        &market_1_initial,
        block_time,
        available_liquidity_uosmo,
        TestUtilizationDeltaInfo {
            less_liquidity: borrow_amount,
            more_debt: borrow_amount,
            ..Default::default()
        },
    );

    let expected_debt_scaled_1_after_borrow = compute_scaled_amount(
        borrow_amount,
        expected_params_uosmo.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    // check correct messages and logging
    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: borrower_addr.to_string(),
            amount: coins(borrow_amount.u128(), "uosmo")
        }))]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/borrow"),
            attr("sender", "borrower"),
            attr("recipient", "borrower"),
            attr("denom", "uosmo"),
            attr("amount", borrow_amount.to_string()),
            attr("amount_scaled", expected_debt_scaled_1_after_borrow),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event("uosmo", &expected_params_uosmo)]);

    // user should have a debt position in `uosmo` but not in `uusd`
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "uosmo")).unwrap();
    assert_eq!(expected_debt_scaled_1_after_borrow, debt.amount_scaled);

    let market_1_after_borrow = MARKETS.load(&deps.storage, "uosmo").unwrap();
    assert_eq!(expected_debt_scaled_1_after_borrow, market_1_after_borrow.debt_total_scaled);
    assert_eq!(expected_params_uosmo.borrow_rate, market_1_after_borrow.borrow_rate);
    assert_eq!(expected_params_uosmo.liquidity_rate, market_1_after_borrow.liquidity_rate);

    // *
    // Borrow uosmo (again)
    // *
    let borrow_amount = Uint128::from(1200u128);
    let block_time = market_1_after_borrow.indexes_last_updated + 20000u64;

    let msg = ExecuteMsg::Borrow {
        denom: "uosmo".to_string(),
        amount: borrow_amount,
        recipient: None,
    };

    let env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);

    execute(deps.as_mut(), env, info, msg).unwrap();

    // user should have a debt position in `uosmo` but not in `uusd`
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let expected_params_uosmo = th_get_expected_indices_and_rates(
        &market_1_after_borrow,
        block_time,
        available_liquidity_uosmo,
        TestUtilizationDeltaInfo {
            less_liquidity: borrow_amount,
            more_debt: borrow_amount,
            ..Default::default()
        },
    );
    let debt = DEBTS.load(&deps.storage, (&borrower_addr, "uosmo")).unwrap();
    let market_1_after_borrow_again = MARKETS.load(&deps.storage, "uosmo").unwrap();

    let expected_debt_scaled_1_after_borrow_again = expected_debt_scaled_1_after_borrow
        + compute_scaled_amount(
            borrow_amount,
            expected_params_uosmo.borrow_index,
            ScalingOperation::Ceil,
        )
        .unwrap();
    assert_eq!(expected_debt_scaled_1_after_borrow_again, debt.amount_scaled);
    assert_eq!(
        expected_debt_scaled_1_after_borrow_again,
        market_1_after_borrow_again.debt_total_scaled
    );
    assert_eq!(expected_params_uosmo.borrow_rate, market_1_after_borrow_again.borrow_rate);
    assert_eq!(expected_params_uosmo.liquidity_rate, market_1_after_borrow_again.liquidity_rate);

    // *
    // Borrow uusd
    // *

    let borrow_amount = Uint128::from(4000u128);
    let block_time = market_1_after_borrow_again.indexes_last_updated + 3000u64;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    let msg = ExecuteMsg::Borrow {
        denom: String::from("uusd"),
        amount: borrow_amount,
        recipient: None,
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    // user should have debt positions in both `uosmo` and `uusd`
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let expected_params_uusd = th_get_expected_indices_and_rates(
        &market_2_initial,
        block_time,
        available_liquidity_uusd,
        TestUtilizationDeltaInfo {
            less_liquidity: borrow_amount,
            more_debt: borrow_amount,
            ..Default::default()
        },
    );

    let expected_debt_scaled_2_after_borrow_2 = compute_scaled_amount(
        borrow_amount,
        expected_params_uusd.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    // check correct messages and logging
    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: "borrower".to_string(),
            amount: coins(borrow_amount.u128(), "uusd")
        }))]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/borrow"),
            attr("sender", "borrower"),
            attr("recipient", "borrower"),
            attr("denom", "uusd"),
            attr("amount", borrow_amount.to_string()),
            attr("amount_scaled", expected_debt_scaled_2_after_borrow_2),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event("uusd", &expected_params_uusd)]);

    let debt2 = DEBTS.load(&deps.storage, (&borrower_addr, "uusd")).unwrap();
    assert_eq!(expected_debt_scaled_2_after_borrow_2, debt2.amount_scaled);

    let market_2_after_borrow_2 = MARKETS.load(&deps.storage, "uusd").unwrap();
    assert_eq!(expected_debt_scaled_2_after_borrow_2, market_2_after_borrow_2.debt_total_scaled);
    assert_eq!(expected_params_uusd.borrow_rate, market_2_after_borrow_2.borrow_rate);
    assert_eq!(expected_params_uusd.liquidity_rate, market_2_after_borrow_2.liquidity_rate);

    // *
    // Borrow native coin again (should fail due to insufficient collateral)
    // *
    let env = mock_env(MockEnvParams::default());
    let info = mock_info("borrower", &[]);
    let msg = ExecuteMsg::Borrow {
        denom: String::from("uusd"),
        amount: Uint128::from(83968_u128),
        recipient: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, ContractError::BorrowAmountExceedsGivenCollateral {});

    // *
    // Repay zero uusd debt (should fail)
    // *
    let env = mock_env_at_block_time(block_time);
    let info = mock_info("borrower", &[]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, PaymentError::NoFunds {}.into());

    // *
    // Repay some uusd debt
    // *
    let repay_amount = Uint128::from(2000u128);
    let block_time = market_2_after_borrow_2.indexes_last_updated + 8000u64;
    let env = mock_env_at_block_time(block_time);
    let info = cosmwasm_std::testing::mock_info("borrower", &[coin(repay_amount.into(), "uusd")]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: None,
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let expected_params_uusd = th_get_expected_indices_and_rates(
        &market_2_after_borrow_2,
        block_time,
        available_liquidity_uusd,
        TestUtilizationDeltaInfo {
            less_debt: repay_amount,
            user_current_debt_scaled: expected_debt_scaled_2_after_borrow_2,
            ..Default::default()
        },
    );

    let expected_repay_amount_scaled = compute_scaled_amount(
        repay_amount,
        expected_params_uusd.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    assert_eq!(res.messages, vec![]);
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/repay"),
            attr("sender", "borrower"),
            attr("on_behalf_of", "borrower"),
            attr("denom", "uusd"),
            attr("amount", repay_amount.to_string()),
            attr("amount_scaled", expected_repay_amount_scaled),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event("uusd", &expected_params_uusd)]);

    // user should have debt positions in both `uosmo` and `uusd`
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let debt2 = DEBTS.load(&deps.storage, (&borrower_addr, "uusd")).unwrap();
    let market_2_after_repay_some_2 = MARKETS.load(&deps.storage, "uusd").unwrap();

    let expected_debt_scaled_2_after_repay_some_2 =
        expected_debt_scaled_2_after_borrow_2 - expected_repay_amount_scaled;
    assert_eq!(expected_debt_scaled_2_after_repay_some_2, debt2.amount_scaled);
    assert_eq!(
        expected_debt_scaled_2_after_repay_some_2,
        market_2_after_repay_some_2.debt_total_scaled
    );
    assert_eq!(expected_params_uusd.borrow_rate, market_2_after_repay_some_2.borrow_rate);
    assert_eq!(expected_params_uusd.liquidity_rate, market_2_after_repay_some_2.liquidity_rate);

    // *
    // Repay all uusd debt
    // *
    let block_time = market_2_after_repay_some_2.indexes_last_updated + 10000u64;
    // need this to compute the repay amount
    let expected_params_uusd = th_get_expected_indices_and_rates(
        &market_2_after_repay_some_2,
        block_time,
        available_liquidity_uusd,
        TestUtilizationDeltaInfo {
            less_debt: Uint128::from(9999999999999_u128), // hack: Just do a big number to repay all debt,
            user_current_debt_scaled: expected_debt_scaled_2_after_repay_some_2,
            ..Default::default()
        },
    );

    let repay_amount: u128 = compute_underlying_amount(
        expected_debt_scaled_2_after_repay_some_2,
        expected_params_uusd.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap()
    .into();

    let env = mock_env_at_block_time(block_time);
    let info = cosmwasm_std::testing::mock_info("borrower", &[coin(repay_amount, "uusd")]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: None,
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    assert_eq!(res.messages, vec![]);
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/repay"),
            attr("sender", "borrower"),
            attr("on_behalf_of", "borrower"),
            attr("denom", "uusd"),
            attr("amount", repay_amount.to_string()),
            attr("amount_scaled", expected_debt_scaled_2_after_repay_some_2),
        ]
    );
    assert_eq!(res.events, vec![th_build_interests_updated_event("uusd", &expected_params_uusd),]);

    // user should no longer has a debt position in uusd
    assert!(has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let market_2_after_repay_all_2 = MARKETS.load(&deps.storage, "uusd").unwrap();
    assert_eq!(Uint128::zero(), market_2_after_repay_all_2.debt_total_scaled);

    // *
    // Repay more uusd debt (should fail)
    // *
    let env = mock_env(MockEnvParams::default());
    let info = cosmwasm_std::testing::mock_info("borrower", &[coin(2000, "uusd")]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, ContractError::CannotRepayZeroDebt {});

    // *
    // Repay all uosmo debt (and then some)
    // *
    let block_time = market_2_after_repay_all_2.indexes_last_updated + 5000u64;
    let repay_amount = Uint128::from(4800u128);

    let expected_params_uosmo = th_get_expected_indices_and_rates(
        &market_1_after_borrow_again,
        block_time,
        available_liquidity_uosmo,
        TestUtilizationDeltaInfo {
            less_debt: repay_amount,
            user_current_debt_scaled: expected_debt_scaled_1_after_borrow_again,
            ..Default::default()
        },
    );

    let env = mock_env_at_block_time(block_time);
    let info = cosmwasm_std::testing::mock_info("borrower", &[coin(repay_amount.u128(), "uosmo")]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: None,
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let expected_refund_amount = repay_amount
        - compute_underlying_amount(
            expected_debt_scaled_1_after_borrow_again,
            expected_params_uosmo.borrow_index,
            ScalingOperation::Ceil,
        )
        .unwrap();

    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: borrower_addr.to_string(),
            amount: coins(expected_refund_amount.u128(), "uosmo")
        }))]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/repay"),
            attr("sender", "borrower"),
            attr("on_behalf_of", "borrower"),
            attr("denom", "uosmo"),
            attr("amount", (repay_amount - expected_refund_amount).to_string()),
            attr("amount_scaled", expected_debt_scaled_1_after_borrow_again),
        ]
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event("uosmo", &expected_params_uosmo),]
    );

    // user should no longer has a debt position in either asset
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, "uosmo"));
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, "uusd"));

    let market_1_after_repay_1 = MARKETS.load(&deps.storage, "uosmo").unwrap();
    assert_eq!(Uint128::zero(), market_1_after_repay_1.debt_total_scaled);
}

#[test]
fn test_repay_without_refund_on_behalf_of() {
    let mut deps = th_setup(&[coin(1000000000u128, "borrowedcoinnative")]);

    deps.querier.set_oracle_price("depositedcoinnative", Decimal::one());
    deps.querier.set_oracle_price("borrowedcoinnative", Decimal::one());

    let mock_market = Market {
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        max_loan_to_value: Decimal::from_ratio(50u128, 100u128),
        ..Default::default()
    };

    let market_1_initial = th_init_market(deps.as_mut(), "depositedcoinnative", &mock_market); // collateral
    let market_2_initial = th_init_market(deps.as_mut(), "borrowedcoinnative", &mock_market);

    let borrower_addr = Addr::unchecked("borrower");
    let user_addr = Addr::unchecked("user");

    // Set user as having the market_1_initial (collateral) deposited
    set_collateral(
        deps.as_mut(),
        &borrower_addr,
        &market_1_initial.denom,
        Uint128::new(10000) * SCALING_FACTOR,
        true,
    );

    // *
    // 'borrower' borrows native coin
    // *
    let borrow_amount = 4000u128;
    let env = mock_env(MockEnvParams::default());
    let info = mock_info(borrower_addr.as_str(), &[]);
    let msg = ExecuteMsg::Borrow {
        denom: String::from("borrowedcoinnative"),
        amount: Uint128::from(borrow_amount),
        recipient: None,
    };
    let _res = execute(deps.as_mut(), env, info, msg).unwrap();

    assert!(has_debt_position(deps.as_ref(), &borrower_addr, &market_2_initial.denom));

    // *
    // 'user' repays debt on behalf of 'borrower'
    // *
    let repay_amount = borrow_amount;
    let env = mock_env(MockEnvParams::default());
    let info = cosmwasm_std::testing::mock_info(
        user_addr.as_str(),
        &[coin(repay_amount, "borrowedcoinnative")],
    );
    let msg = ExecuteMsg::Repay {
        on_behalf_of: Some(borrower_addr.to_string()),
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    // 'user' should not have positions in either the collateral or debt asset
    assert!(!has_collateral_position(deps.as_ref(), &user_addr, &market_1_initial.denom));
    assert!(!has_debt_position(deps.as_ref(), &user_addr, &market_2_initial.denom));

    // Debt for 'borrower' should be repayed in full, with the position deleted
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, &market_2_initial.denom));

    // Check msgs and attributes
    assert_eq!(res.messages, vec![]);
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/repay"),
            attr("sender", "user"),
            attr("on_behalf_of", "borrower"),
            attr("denom", "borrowedcoinnative"),
            attr("amount", repay_amount.to_string()),
            attr("amount_scaled", Uint128::new(repay_amount) * SCALING_FACTOR),
        ]
    );
}

#[test]
fn test_repay_with_refund_on_behalf_of() {
    let mut deps = th_setup(&[coin(1000000000u128, "borrowedcoinnative")]);

    deps.querier.set_oracle_price("depositedcoinnative", Decimal::one());
    deps.querier.set_oracle_price("borrowedcoinnative", Decimal::one());

    let mock_market = Market {
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        max_loan_to_value: Decimal::from_ratio(50u128, 100u128),
        ..Default::default()
    };

    let market_1_initial = th_init_market(deps.as_mut(), "depositedcoinnative", &mock_market); // collateral
    let market_2_initial = th_init_market(deps.as_mut(), "borrowedcoinnative", &mock_market);

    let borrower_addr = Addr::unchecked("borrower");
    let user_addr = Addr::unchecked("user");

    // Set user as having the market_1_initial (collateral) deposited
    set_collateral(
        deps.as_mut(),
        &borrower_addr,
        &market_1_initial.denom,
        Uint128::new(10000) * SCALING_FACTOR,
        true,
    );

    // *
    // 'borrower' borrows native coin
    // *
    let borrow_amount = 4000u128;
    let env = mock_env(MockEnvParams::default());
    let info = mock_info(borrower_addr.as_str(), &[]);
    let msg = ExecuteMsg::Borrow {
        denom: String::from("borrowedcoinnative"),
        amount: Uint128::from(borrow_amount),
        recipient: None,
    };
    let _res = execute(deps.as_mut(), env, info, msg).unwrap();

    assert!(has_debt_position(deps.as_ref(), &borrower_addr, &market_2_initial.denom));

    // *
    // 'user' repays part of the debt on behalf of 'borrower'
    // *
    let refund_amount = 800u128;
    let repay_amount = borrow_amount + refund_amount;
    let env = mock_env(MockEnvParams::default());
    let info = cosmwasm_std::testing::mock_info(
        user_addr.as_str(),
        &[coin(repay_amount, "borrowedcoinnative")],
    );
    let msg = ExecuteMsg::Repay {
        on_behalf_of: Some(borrower_addr.to_string()),
    };
    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    // 'user' should not have positions in either the collateral or debt asset
    assert!(!has_collateral_position(deps.as_ref(), &user_addr, &market_1_initial.denom));
    assert!(!has_debt_position(deps.as_ref(), &user_addr, &market_2_initial.denom));

    // Debt for 'borrower' should be partially repayed
    assert!(!has_debt_position(deps.as_ref(), &borrower_addr, &market_2_initial.denom));

    // Check msgs and attributes
    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: user_addr.to_string(),
            amount: coins(refund_amount, "borrowedcoinnative")
        }))]
    );
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/repay"),
            attr("sender", "user"),
            attr("on_behalf_of", "borrower"),
            attr("denom", "borrowedcoinnative"),
            attr("amount", borrow_amount.to_string()),
            attr("amount_scaled", Uint128::new(borrow_amount) * SCALING_FACTOR),
        ]
    );
}

#[test]
fn test_repay_uncollateralized_loan_on_behalf_of() {
    let mut deps = th_setup(&[]);

    let repayer_addr = Addr::unchecked("repayer");
    let another_user_addr = Addr::unchecked("another_user");

    UNCOLLATERALIZED_LOAN_LIMITS
        .save(deps.as_mut().storage, (&another_user_addr, "somecoin"), &Uint128::new(1000u128))
        .unwrap();

    let env = mock_env(MockEnvParams::default());
    let info = cosmwasm_std::testing::mock_info(repayer_addr.as_str(), &[coin(110000, "somecoin")]);
    let msg = ExecuteMsg::Repay {
        on_behalf_of: Some(another_user_addr.to_string()),
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, ContractError::CannotRepayUncollateralizedLoanOnBehalfOf {});
}

#[test]
fn test_borrow_full_liquidity_and_then_repay() {
    let initial_liquidity = 50000;
    let mut deps = th_setup(&[coin(initial_liquidity, "uusd")]);
    let info = mock_info("borrower", &[]);
    let borrower_addr = Addr::unchecked("borrower");
    let block_time = 1;
    let ltv = Decimal::one();

    let mock_market = Market {
        liquidity_index: Decimal::one(),
        max_loan_to_value: ltv,
        borrow_index: Decimal::one(),
        borrow_rate: Decimal::one(),
        liquidity_rate: Decimal::one(),
        debt_total_scaled: Uint128::zero(),
        reserve_factor: Decimal::from_ratio(12u128, 100u128),
        indexes_last_updated: block_time,
        ..Default::default()
    };
    th_init_market(deps.as_mut(), "uusd", &mock_market);

    // User should have amount of collateral more than initial liquidity in order to borrow full liquidity
    let deposit_amount = initial_liquidity + 1000u128;
    set_collateral(
        deps.as_mut(),
        &borrower_addr,
        "uusd",
        Uint128::new(deposit_amount) * SCALING_FACTOR,
        true,
    );

    // Borrow full liquidity
    {
        let env = mock_env_at_block_time(block_time);
        let msg = ExecuteMsg::Borrow {
            denom: "uusd".to_string(),
            amount: initial_liquidity.into(),
            recipient: None,
        };
        let _res = execute(deps.as_mut(), env, info.clone(), msg).unwrap();

        let market_after_borrow = MARKETS.load(&deps.storage, "uusd").unwrap();
        let debt_total = compute_underlying_amount(
            market_after_borrow.debt_total_scaled,
            market_after_borrow.borrow_index,
            ScalingOperation::Ceil,
        )
        .unwrap();
        assert_eq!(debt_total.u128(), initial_liquidity);
    }

    let new_block_time = 12000u64;
    // We need to update balance after borrowing
    deps.querier.set_contract_balances(&[coin(0, "uusd")]);

    // Try to borrow more than available liquidity
    {
        let env = mock_env_at_block_time(new_block_time);
        let msg = ExecuteMsg::Borrow {
            denom: "uusd".to_string(),
            amount: 100u128.into(),
            recipient: None,
        };
        let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
        assert_eq!(error_res, ContractError::OperationExceedsAvailableLiquidity {});
    }

    // Repay part of the debt
    {
        let env = mock_env_at_block_time(new_block_time);
        let info = cosmwasm_std::testing::mock_info("borrower", &[coin(2000, "uusd")]);
        let msg = ExecuteMsg::Repay {
            on_behalf_of: None,
        };
        // check that repay succeeds
        execute(deps.as_mut(), env, info, msg).unwrap();
    }
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`on_behalf_of`](focus://json#3)      | `Option<String>`       | Repay the funds for the user       |

</CH.Section>

<img src={RedBankRepayUrl} />


### `liquidate`

Liquidate under-collateralized native loans. Coins used to repay must be sent in the transaction this call is made.  The liquidator will receive collateral shares. To get the underlying asset, consider sending a separate [`withdraw`](#withdraw) execute message.

<CH.Section>
<CH.Code>

```json json
{
    "liquidate": {
        "user": "mars...",
        "collateral_denom": "...",
        "recipient": "..."
    }
}
```

```rust msg.rs focus=1:3,36:40,45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,50:67,72:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn liquidate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    collateral_denom: String,
    debt_denom: String,
    user_addr: Addr,
    sent_debt_amount: Uint128,
    recipient: Option<String>,
) -> Result<Response, ContractError> {
    let block_time = env.block.time.seconds();
    let user = User(&user_addr);
    // The recipient address for receiving underlying collateral
    let recipient_addr = option_string_to_addr(deps.api, recipient, info.sender.clone())?;
    let recipient = User(&recipient_addr);

    // 1. Validate liquidation
    // If user (contract) has a positive uncollateralized limit then the user
    // cannot be liquidated
    if !user.uncollateralized_loan_limit(deps.storage, &debt_denom)?.is_zero() {
        return Err(ContractError::CannotLiquidateWhenPositiveUncollateralizedLoanLimit {});
    };

    // check if the user has enabled the collateral asset as collateral
    let user_collateral = COLLATERALS
        .may_load(deps.storage, (&user_addr, &collateral_denom))?
        .ok_or(ContractError::CannotLiquidateWhenNoCollateralBalance {})?;
    if !user_collateral.enabled {
        return Err(ContractError::CannotLiquidateWhenCollateralUnset {
            denom: collateral_denom,
        });
    }

    // check if user has available collateral in specified collateral asset to be liquidated
    let collateral_market = MARKETS.load(deps.storage, &collateral_denom)?;

    // check if user has outstanding debt in the deposited asset that needs to be repayed
    let user_debt = DEBTS
        .may_load(deps.storage, (&user_addr, &debt_denom))?
        .ok_or(ContractError::CannotLiquidateWhenNoDebtBalance {})?;

    // 2. Compute health factor
    let config = CONFIG.load(deps.storage)?;

    let addresses = address_provider::helpers::query_addresses(
        deps.as_ref(),
        &config.address_provider,
        vec![
            MarsAddressType::Oracle,
            MarsAddressType::Incentives,
            MarsAddressType::RewardsCollector,
        ],
    )?;
    let rewards_collector_addr = &addresses[&MarsAddressType::RewardsCollector];
    let incentives_addr = &addresses[&MarsAddressType::Incentives];
    let oracle_addr = &addresses[&MarsAddressType::Oracle];

    let (liquidatable, assets_positions) =
        assert_liquidatable(&deps.as_ref(), &env, &user_addr, oracle_addr)?;

    if !liquidatable {
        return Err(ContractError::CannotLiquidateHealthyPosition {});
    }

    let collateral_and_debt_are_the_same_asset = debt_denom == collateral_denom;

    let debt_market = if !collateral_and_debt_are_the_same_asset {
        MARKETS.load(deps.storage, &debt_denom)?
    } else {
        collateral_market.clone()
    };

    // 3. Compute debt to repay and collateral to liquidate
    let collateral_price = assets_positions
        .get(&collateral_denom)
        .ok_or(ContractError::CannotLiquidateWhenNoCollateralBalance {})?
        .asset_price;
    let debt_price = assets_positions
        .get(&debt_denom)
        .ok_or(ContractError::CannotLiquidateWhenNoDebtBalance {})?
        .asset_price;

    let mut response = Response::new();

    let user_debt_amount =
        get_underlying_debt_amount(user_debt.amount_scaled, &debt_market, block_time)?;

    let (
        debt_amount_to_repay,
        collateral_amount_to_liquidate,
        collateral_amount_to_liquidate_scaled,
        refund_amount,
    ) = liquidation_compute_amounts(
        user_collateral.amount_scaled,
        user_debt_amount,
        sent_debt_amount,
        &collateral_market,
        collateral_price,
        debt_price,
        block_time,
        config.close_factor,
    )?;

    // 4. Transfer collateral shares from the user to the liquidator
    response = user.decrease_collateral(
        deps.storage,
        &collateral_market,
        collateral_amount_to_liquidate_scaled,
        incentives_addr,
        response,
    )?;
    response = recipient.increase_collateral(
        deps.storage,
        &collateral_market,
        collateral_amount_to_liquidate_scaled,
        incentives_addr,
        response,
    )?;

    // 5. Reduce the user's debt shares
    let user_debt_amount_after = user_debt_amount.checked_sub(debt_amount_to_repay)?;
    let user_debt_amount_scaled_after =
        get_scaled_debt_amount(user_debt_amount_after, &debt_market, block_time)?;

    // Compute delta so it can be substracted to total debt
    let debt_amount_scaled_delta =
        user_debt.amount_scaled.checked_sub(user_debt_amount_scaled_after)?;

    user.decrease_debt(deps.storage, &debt_denom, debt_amount_scaled_delta)?;

    let debt_market_debt_total_scaled_after =
        debt_market.debt_total_scaled.checked_sub(debt_amount_scaled_delta)?;

    // 6. Update markets depending on whether the collateral and debt markets are the same
    // and whether the liquidator receives ma_tokens (no change in liquidity) or underlying asset
    // (changes liquidity)
    if collateral_and_debt_are_the_same_asset {
        // NOTE: for the sake of clarity copy attributes from collateral market and
        // give generic naming. Debt market could have been used as well
        let mut asset_market_after = collateral_market;
        let denom = &collateral_denom;

        response = apply_accumulated_interests(
            deps.storage,
            &env,
            &mut asset_market_after,
            rewards_collector_addr,
            incentives_addr,
            response,
        )?;

        asset_market_after.debt_total_scaled = debt_market_debt_total_scaled_after;

        response = update_interest_rates(
            &deps,
            &env,
            &mut asset_market_after,
            refund_amount,
            denom,
            response,
        )?;

        MARKETS.save(deps.storage, denom, &asset_market_after)?;
    } else {
        let mut debt_market_after = debt_market;

        response = apply_accumulated_interests(
            deps.storage,
            &env,
            &mut debt_market_after,
            rewards_collector_addr,
            incentives_addr,
            response,
        )?;

        debt_market_after.debt_total_scaled = debt_market_debt_total_scaled_after;

        response = update_interest_rates(
            &deps,
            &env,
            &mut debt_market_after,
            refund_amount,
            &debt_denom,
            response,
        )?;

        MARKETS.save(deps.storage, &debt_denom, &debt_market_after)?;
    }

    // 7. Build response
    // refund sent amount in excess of actual debt amount to liquidate
    if !refund_amount.is_zero() {
        response =
            response.add_message(build_send_asset_msg(&info.sender, &debt_denom, refund_amount));
    }

    Ok(response
        .add_attribute("action", "outposts/red-bank/liquidate")
        .add_attribute("user", user)
        .add_attribute("liquidator", info.sender.to_string())
        .add_attribute("recipient", recipient)
        .add_attribute("collateral_denom", collateral_denom)
        .add_attribute("collateral_amount", collateral_amount_to_liquidate)
        .add_attribute("collateral_amount_scaled", collateral_amount_to_liquidate_scaled)
        .add_attribute("debt_denom", debt_denom)
        .add_attribute("debt_amount", debt_amount_to_repay)
        .add_attribute("debt_amount_scaled", debt_amount_scaled_delta))
}
```

```rust test
#[test]
fn liquidate_if_no_coins_sent() {
    let TestSuite {
        mut deps,
        ..
    } = setup_test();

    let env = mock_env(MockEnvParams::default());
    let info = mock_info("liquidator", &[]);
    let msg = ExecuteMsg::Liquidate {
        user: "user".to_string(),
        collateral_denom: "collateral".to_string(),
        recipient: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, PaymentError::NoFunds {}.into());
}

#[test]
fn liquidate_if_many_coins_sent() {
    let TestSuite {
        mut deps,
        ..
    } = setup_test();

    let env = mock_env(MockEnvParams::default());
    let info = mock_info("liquidator", &[coin(100, "somecoin1"), coin(200, "somecoin2")]);
    let msg = ExecuteMsg::Liquidate {
        user: "user".to_string(),
        collateral_denom: "collateral".to_string(),
        recipient: None,
    };
    let error_res = execute(deps.as_mut(), env, info, msg).unwrap_err();
    assert_eq!(error_res, PaymentError::MultipleDenoms {}.into());
}

#[test]
fn liquidate_if_no_collateral() {
    let TestSuite {
        mut deps,
        collateral_coin,
        debt_coin,
        ..
    } = setup_test();

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: "user".to_string(),
        collateral_denom: collateral_coin.denom,
        recipient: None,
    };

    let env = mock_env(MockEnvParams::default());
    let info = mock_info("liquidator", &coins(400_000_u128, debt_coin.denom));
    let error_res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap_err();
    assert_eq!(error_res, ContractError::CannotLiquidateWhenNoCollateralBalance {});
}

#[test]
fn liquidate_if_only_uncollateralized_debt_exists() {
    let TestSuite {
        mut deps,
        collateral_coin,
        debt_coin,
        uncollateralized_denom,
        collateral_market,
        ..
    } = setup_test();

    let user_addr = Addr::unchecked("user");

    set_collateral(
        deps.as_mut(),
        &user_addr,
        &collateral_market.denom,
        Uint128::new(2_000_000),
        true,
    );
    set_debt(deps.as_mut(), &user_addr, uncollateralized_denom, Uint128::new(10_000), true);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: collateral_coin.denom,
        recipient: None,
    };

    let env = mock_env(MockEnvParams::default());
    let info = mock_info("liquidator", &coins(400_000_u128, debt_coin.denom));
    // trying to liquidate user with zero outstanding debt should fail (uncollateralized has not impact)
    let error_res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap_err();
    assert_eq!(error_res, ContractError::CannotLiquidateWhenNoDebtBalance {});
}

#[test]
fn liquidate_partially() {
    let mut ts = setup_test();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");

    let user_collateral_scaled_before = Uint128::from(2_000_000u64) * SCALING_FACTOR;
    let user_debt_scaled_before = compute_scaled_amount(
        Uint128::from(3_000_000u64),
        ts.debt_market.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    set_collateral(
        ts.deps.as_mut(),
        &user_addr,
        &ts.collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(ts.deps.as_mut(), &user_addr, &ts.debt_market.denom, user_debt_scaled_before, false);
    set_debt(
        ts.deps.as_mut(),
        &user_addr,
        ts.uncollateralized_denom,
        Uint128::new(10_000) * SCALING_FACTOR,
        true,
    );

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: ts.collateral_market.denom.clone(),
        recipient: None,
    };

    let debt_to_repay = Uint128::from(400_000_u64);
    let block_time = 15_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), ts.debt_market.denom.clone()),
    );
    let res = execute(ts.deps.as_mut(), env, info, liquidate_msg).unwrap();

    let TestExpectedAmountResults {
        user_debt_repayed,
        user_debt_repayed_scaled,
        expected_liquidated_collateral_amount,
        expected_liquidated_collateral_amount_scaled,
        expected_reward_amount_scaled,
        expected_debt_rates,
        ..
    } = expected_amounts(block_time, user_debt_scaled_before, debt_to_repay, &ts);

    let expected_msgs = expected_messages(
        &user_addr,
        &liquidator_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &ts.collateral_market,
        &ts.debt_market,
    );
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", liquidator_addr.as_str()),
            attr("collateral_denom", ts.collateral_market.denom.as_str()),
            attr("collateral_amount", expected_liquidated_collateral_amount),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", ts.debt_market.denom.as_str()),
            attr("debt_amount", user_debt_repayed),
            attr("debt_amount_scaled", user_debt_repayed_scaled),
        ],
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&ts.debt_market.denom, &expected_debt_rates)]
    );

    let debt_market_after = MARKETS.load(&ts.deps.storage, &ts.debt_market.denom).unwrap();

    // user's collateral scaled amount should have been correctly decreased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&user_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(
        collateral.amount_scaled,
        user_collateral_scaled_before - expected_liquidated_collateral_amount_scaled
    );

    // liquidator's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&liquidator_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&ts.deps.storage, (&user_addr, &ts.debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - user_debt_repayed_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        ts.debt_market.debt_total_scaled - user_debt_repayed_scaled
    );

    // rewards collector's collateral scaled amount **of the debt asset** should have been correctly increased
    let collateral = rewards_collector_collateral(ts.deps.as_ref(), &ts.debt_market.denom);
    assert_eq!(collateral.amount_scaled, expected_reward_amount_scaled);

    // global collateral scaled amount **of the debt asset** should have been correctly increased
    assert_eq!(
        debt_market_after.collateral_total_scaled,
        ts.debt_market.collateral_total_scaled + expected_reward_amount_scaled
    );
}

#[test]
fn liquidate_up_to_close_factor_with_refund() {
    let mut ts = setup_test();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");

    let user_collateral_scaled_before = Uint128::from(2_000_000u64) * SCALING_FACTOR;
    let user_debt_scaled_before = compute_scaled_amount(
        Uint128::from(3_000_000u64),
        ts.debt_market.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    set_collateral(
        ts.deps.as_mut(),
        &user_addr,
        &ts.collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(ts.deps.as_mut(), &user_addr, &ts.debt_market.denom, user_debt_scaled_before, false);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: ts.collateral_market.denom.clone(),
        recipient: None,
    };

    let debt_to_repay = Uint128::from(10_000_000_u64);
    let block_time = 16_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), ts.debt_market.denom.clone()),
    );
    let res = execute(ts.deps.as_mut(), env, info, liquidate_msg).unwrap();

    let TestExpectedAmountResults {
        user_debt_repayed,
        user_debt_repayed_scaled,
        expected_refund_amount,
        expected_liquidated_collateral_amount,
        expected_liquidated_collateral_amount_scaled,
        expected_reward_amount_scaled,
        expected_debt_rates,
        ..
    } = expected_amounts(block_time, user_debt_scaled_before, debt_to_repay, &ts);

    let mut expected_msgs = expected_messages(
        &user_addr,
        &liquidator_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &ts.collateral_market,
        &ts.debt_market,
    );
    expected_msgs.push(SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
        to_address: liquidator_addr.to_string(),
        amount: coins(expected_refund_amount.u128(), ts.debt_market.denom.clone()),
    })));
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", liquidator_addr.as_str()),
            attr("collateral_denom", ts.collateral_market.denom.as_str()),
            attr("collateral_amount", expected_liquidated_collateral_amount),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", ts.debt_market.denom.as_str()),
            attr("debt_amount", user_debt_repayed),
            attr("debt_amount_scaled", user_debt_repayed_scaled),
        ],
        res.attributes,
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&ts.debt_market.denom, &expected_debt_rates)],
    );

    let debt_market_after = MARKETS.load(&ts.deps.storage, &ts.debt_market.denom).unwrap();

    // user's collateral scaled amount should have been correctly decreased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&user_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(
        collateral.amount_scaled,
        user_collateral_scaled_before - expected_liquidated_collateral_amount_scaled
    );

    // liquidator's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&liquidator_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&ts.deps.storage, (&user_addr, &ts.debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - expected_debt_rates.less_debt_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        ts.debt_market.debt_total_scaled - expected_debt_rates.less_debt_scaled
    );

    // rewards collector's collateral scaled amount **of the debt asset** should have been correctly increased
    let collateral = rewards_collector_collateral(ts.deps.as_ref(), &ts.debt_market.denom);
    assert_eq!(collateral.amount_scaled, expected_reward_amount_scaled);

    // global collateral scaled amount **of the debt asset** should have been correctly increased
    assert_eq!(
        debt_market_after.collateral_total_scaled,
        ts.debt_market.collateral_total_scaled + expected_reward_amount_scaled
    );
}

#[test]
fn liquidate_fully() {
    let TestSuite {
        mut deps,
        debt_coin,
        collateral_price,
        debt_price,
        collateral_market,
        debt_market,
        ..
    } = setup_test();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");

    let user_collateral_scaled_before = Uint128::new(100) * SCALING_FACTOR;
    let user_debt_scaled_before = Uint128::new(400) * SCALING_FACTOR;

    set_collateral(
        deps.as_mut(),
        &user_addr,
        &collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(deps.as_mut(), &user_addr, &debt_market.denom, user_debt_scaled_before, false);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: collateral_market.denom.clone(),
        recipient: None,
    };

    let debt_to_repay = Uint128::from(300u128);
    let block_time = 16_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), debt_market.denom.clone()),
    );
    let res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap();

    // get expected indices and rates for debt and collateral markets
    let expected_collateral_indices = th_get_expected_indices(&collateral_market, block_time);
    let user_collateral_balance = compute_underlying_amount(
        user_collateral_scaled_before,
        expected_collateral_indices.liquidity,
        ScalingOperation::Truncate,
    )
    .unwrap();

    // Since debt is being over_repayed, we expect to liquidate total collateral
    let expected_less_debt = math::divide_uint128_by_decimal(
        math::divide_uint128_by_decimal(collateral_price * user_collateral_balance, debt_price)
            .unwrap(),
        Decimal::one() + collateral_market.liquidation_bonus,
    )
    .unwrap();

    let expected_refund_amount = debt_to_repay - expected_less_debt;

    let expected_debt_rates = th_get_expected_indices_and_rates(
        &debt_market,
        block_time,
        debt_coin.amount,
        TestUtilizationDeltaInfo {
            less_debt: expected_less_debt,
            user_current_debt_scaled: user_debt_scaled_before,
            less_liquidity: expected_refund_amount,
            ..Default::default()
        },
    );

    let debt_market_after = MARKETS.load(&deps.storage, &debt_market.denom).unwrap();

    // since this is a full liquidation, the full amount of user's collateral shares should have
    // been transferred to the liquidator
    let expected_liquidated_collateral_amount_scaled = user_collateral_scaled_before;

    let mut expected_msgs = expected_messages(
        &user_addr,
        &liquidator_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &collateral_market,
        &debt_market,
    );
    expected_msgs.push(SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
        to_address: liquidator_addr.to_string(),
        amount: coins(expected_refund_amount.u128(), debt_market.denom.clone()),
    })));
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", liquidator_addr.as_str()),
            attr("collateral_denom", collateral_market.denom.as_str()),
            attr("collateral_amount", user_collateral_balance),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", debt_market.denom.as_str()),
            attr("debt_amount", expected_less_debt),
            attr("debt_amount_scaled", expected_debt_rates.less_debt_scaled),
        ],
        res.attributes,
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&debt_market.denom, &expected_debt_rates)],
    );

    // since this is a full liquidation, the user's collateral position should have been deleted
    assert!(!has_collateral_position(deps.as_ref(), &user_addr, &collateral_market.denom));

    // liquidator's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(deps.as_ref().storage, (&liquidator_addr, &collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&deps.storage, (&user_addr, &debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - expected_debt_rates.less_debt_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        debt_market.debt_total_scaled - expected_debt_rates.less_debt_scaled
    );
}

#[test]
fn liquidate_partially_if_same_asset_for_debt_and_collateral() {
    let TestSuite {
        mut deps,
        collateral_coin,
        collateral_price,
        collateral_market,
        ..
    } = setup_test();
    let debt_coin = collateral_coin;
    let debt_price = collateral_price;
    let debt_market = collateral_market.clone();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");

    let user_collateral_scaled_before = Uint128::from(2_000_000u64) * SCALING_FACTOR;
    let user_debt_scaled_before = compute_scaled_amount(
        Uint128::from(3_000_000u64),
        debt_market.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    set_collateral(
        deps.as_mut(),
        &user_addr,
        &collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(deps.as_mut(), &user_addr, &debt_market.denom, user_debt_scaled_before, false);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: collateral_market.denom.clone(),
        recipient: None,
    };

    let debt_to_repay = Uint128::from(400_000_u64);
    let block_time = 15_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), debt_market.denom.clone()),
    );
    let res = execute(deps.as_mut(), env.clone(), info, liquidate_msg).unwrap();

    // get expected indices and rates for debt market
    let expected_debt_rates = th_get_expected_indices_and_rates(
        &debt_market,
        block_time,
        debt_coin.amount,
        TestUtilizationDeltaInfo {
            less_debt: debt_to_repay,
            user_current_debt_scaled: user_debt_scaled_before,
            ..Default::default()
        },
    );

    let collateral_market_after = MARKETS.load(&deps.storage, &collateral_market.denom).unwrap();
    let debt_market_after = MARKETS.load(&deps.storage, &debt_market.denom).unwrap();

    let expected_liquidated_collateral_amount = math::divide_uint128_by_decimal(
        debt_to_repay * debt_price * (Decimal::one() + collateral_market.liquidation_bonus),
        collateral_price,
    )
    .unwrap();

    let expected_liquidated_collateral_amount_scaled = get_scaled_liquidity_amount(
        expected_liquidated_collateral_amount,
        &collateral_market_after,
        env.block.time.seconds(),
    )
    .unwrap();

    let expected_reward_amount_scaled = compute_scaled_amount(
        expected_debt_rates.protocol_rewards_to_distribute,
        expected_debt_rates.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_msgs = expected_messages(
        &user_addr,
        &liquidator_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &collateral_market,
        &debt_market,
    );
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        res.attributes,
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", liquidator_addr.as_str()),
            attr("collateral_denom", collateral_market.denom.as_str()),
            attr("collateral_amount", expected_liquidated_collateral_amount),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", debt_market.denom.as_str()),
            attr("debt_amount", debt_to_repay),
            attr("debt_amount_scaled", expected_debt_rates.less_debt_scaled),
        ],
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&debt_market.denom, &expected_debt_rates)]
    );

    // user's collateral scaled amount should have been correctly decreased
    let collateral =
        COLLATERALS.load(deps.as_ref().storage, (&user_addr, &collateral_market.denom)).unwrap();
    assert_eq!(
        collateral.amount_scaled,
        user_collateral_scaled_before - expected_liquidated_collateral_amount_scaled
    );

    // liquidator's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(deps.as_ref().storage, (&liquidator_addr, &collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&deps.storage, (&user_addr, &debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - expected_debt_rates.less_debt_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        debt_market.debt_total_scaled - expected_debt_rates.less_debt_scaled
    );

    // rewards collector's collateral scaled amount **of the debt asset** should have been correctly increased
    let collateral = rewards_collector_collateral(deps.as_ref(), &debt_market.denom);
    assert_eq!(collateral.amount_scaled, expected_reward_amount_scaled);

    // global collateral scaled amount **of the debt asset** should have been correctly increased
    assert_eq!(
        debt_market_after.collateral_total_scaled,
        debt_market.collateral_total_scaled + expected_reward_amount_scaled
    );
}

#[test]
fn liquidate_with_refund_if_same_asset_for_debt_and_collateral() {
    let TestSuite {
        mut deps,
        collateral_coin,
        collateral_price,
        close_factor,
        collateral_market,
        ..
    } = setup_test();
    let debt_coin = collateral_coin.clone();
    let debt_price = collateral_price;
    let debt_market = collateral_market.clone();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");

    let user_collateral_scaled_before = Uint128::from(2_000_000u64) * SCALING_FACTOR;
    let user_debt_scaled_before = compute_scaled_amount(
        Uint128::from(3_000_000u64),
        debt_market.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    set_collateral(
        deps.as_mut(),
        &user_addr,
        &collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(deps.as_mut(), &user_addr, &debt_market.denom, user_debt_scaled_before, false);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: collateral_market.denom.clone(),
        recipient: None,
    };

    let debt_to_repay = Uint128::from(10_000_000_u64);
    let block_time = 16_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), debt_market.denom.clone()),
    );
    let res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap();

    // get expected indices and rates for debt and collateral markets
    let expected_debt_indices = th_get_expected_indices(&debt_market, block_time);
    let user_debt_asset_total_debt = compute_underlying_amount(
        user_debt_scaled_before,
        expected_debt_indices.borrow,
        ScalingOperation::Ceil,
    )
    .unwrap();
    // since debt is being over_repayed, we expect to max out the liquidatable debt
    let expected_less_debt = user_debt_asset_total_debt * close_factor;

    let expected_refund_amount = debt_to_repay - expected_less_debt;

    let expected_debt_rates = th_get_expected_indices_and_rates(
        &debt_market,
        block_time,
        debt_coin.amount,
        TestUtilizationDeltaInfo {
            less_debt: expected_less_debt,
            user_current_debt_scaled: user_debt_scaled_before,
            less_liquidity: expected_refund_amount,
            ..Default::default()
        },
    );

    let expected_liquidated_collateral_amount = math::divide_uint128_by_decimal(
        expected_less_debt * debt_price * (Decimal::one() + collateral_market.liquidation_bonus),
        collateral_price,
    )
    .unwrap();

    let expected_collateral_rates = th_get_expected_indices_and_rates(
        &collateral_market,
        block_time,
        collateral_coin.amount,
        TestUtilizationDeltaInfo {
            less_liquidity: expected_liquidated_collateral_amount,
            ..Default::default()
        },
    );

    let debt_market_after = MARKETS.load(&deps.storage, &debt_market.denom).unwrap();

    let expected_liquidated_collateral_amount_scaled = compute_scaled_amount(
        expected_liquidated_collateral_amount,
        expected_collateral_rates.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let expected_reward_amount_scaled = compute_scaled_amount(
        expected_debt_rates.protocol_rewards_to_distribute,
        expected_debt_rates.liquidity_index,
        ScalingOperation::Truncate,
    )
    .unwrap();

    let mut expected_msgs = expected_messages(
        &user_addr,
        &liquidator_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &collateral_market,
        &debt_market,
    );
    expected_msgs.push(SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
        to_address: liquidator_addr.to_string(),
        amount: coins(expected_refund_amount.u128(), debt_market.denom.clone()),
    })));
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", liquidator_addr.as_str()),
            attr("collateral_denom", collateral_market.denom.as_str()),
            attr("collateral_amount", expected_liquidated_collateral_amount),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", debt_market.denom.as_str()),
            attr("debt_amount", expected_less_debt),
            attr("debt_amount_scaled", expected_debt_rates.less_debt_scaled),
        ],
        res.attributes,
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&debt_market.denom, &expected_debt_rates)],
    );

    // user's collateral scaled amount should have been correctly decreased
    let collateral =
        COLLATERALS.load(deps.as_ref().storage, (&user_addr, &collateral_market.denom)).unwrap();
    assert_eq!(
        collateral.amount_scaled,
        user_collateral_scaled_before - expected_liquidated_collateral_amount_scaled
    );

    // liquidator's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(deps.as_ref().storage, (&liquidator_addr, &collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&deps.storage, (&user_addr, &debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - expected_debt_rates.less_debt_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        debt_market.debt_total_scaled - expected_debt_rates.less_debt_scaled
    );

    // rewards collector's collateral scaled amount **of the debt asset** should have been correctly increased
    let collateral = rewards_collector_collateral(deps.as_ref(), &debt_market.denom);
    assert_eq!(collateral.amount_scaled, expected_reward_amount_scaled);

    // global collateral scaled amount **of the debt asset** should have been correctly increased
    assert_eq!(
        debt_market_after.collateral_total_scaled,
        debt_market.collateral_total_scaled + expected_reward_amount_scaled
    );
}

#[test]
fn liquidate_with_recipient_for_underlying_collateral() {
    let mut ts = setup_test();

    let user_addr = Addr::unchecked("user");
    let liquidator_addr = Addr::unchecked("liquidator");
    let recipient_addr = Addr::unchecked("recipient");

    let user_collateral_scaled_before = Uint128::from(2_000_000u64) * SCALING_FACTOR;
    let user_debt_scaled_before = compute_scaled_amount(
        Uint128::from(3_000_000u64),
        ts.debt_market.borrow_index,
        ScalingOperation::Ceil,
    )
    .unwrap();

    set_collateral(
        ts.deps.as_mut(),
        &user_addr,
        &ts.collateral_market.denom,
        user_collateral_scaled_before,
        true,
    );
    set_debt(ts.deps.as_mut(), &user_addr, &ts.debt_market.denom, user_debt_scaled_before, false);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: ts.collateral_market.denom.clone(),
        recipient: Some(recipient_addr.to_string()),
    };

    let debt_to_repay = Uint128::from(10_000_000_u64);
    let block_time = 16_000_000;
    let env = mock_env_at_block_time(block_time);
    let info = mock_info(
        liquidator_addr.as_str(),
        &coins(debt_to_repay.u128(), ts.debt_market.denom.clone()),
    );
    let res = execute(ts.deps.as_mut(), env, info, liquidate_msg).unwrap();

    let TestExpectedAmountResults {
        user_debt_repayed,
        user_debt_repayed_scaled,
        expected_refund_amount,
        expected_liquidated_collateral_amount,
        expected_liquidated_collateral_amount_scaled,
        expected_reward_amount_scaled,
        expected_debt_rates,
        ..
    } = expected_amounts(block_time, user_debt_scaled_before, debt_to_repay, &ts);

    let mut expected_msgs = expected_messages(
        &user_addr,
        &recipient_addr,
        user_collateral_scaled_before,
        Uint128::zero(),
        &ts.collateral_market,
        &ts.debt_market,
    );
    expected_msgs.push(SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
        to_address: liquidator_addr.to_string(),
        amount: coins(expected_refund_amount.u128(), ts.debt_market.denom.clone()),
    })));
    assert_eq!(res.messages, expected_msgs);

    mars_testing::assert_eq_vec(
        vec![
            attr("action", "outposts/red-bank/liquidate"),
            attr("user", user_addr.as_str()),
            attr("liquidator", liquidator_addr.as_str()),
            attr("recipient", recipient_addr.as_str()),
            attr("collateral_denom", ts.collateral_market.denom.as_str()),
            attr("collateral_amount", expected_liquidated_collateral_amount),
            attr("collateral_amount_scaled", expected_liquidated_collateral_amount_scaled),
            attr("debt_denom", ts.debt_market.denom.as_str()),
            attr("debt_amount", user_debt_repayed),
            attr("debt_amount_scaled", user_debt_repayed_scaled),
        ],
        res.attributes,
    );
    assert_eq!(
        res.events,
        vec![th_build_interests_updated_event(&ts.debt_market.denom, &expected_debt_rates)],
    );

    let debt_market_after = MARKETS.load(&ts.deps.storage, &ts.debt_market.denom).unwrap();

    // user's collateral scaled amount should have been correctly decreased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&user_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(
        collateral.amount_scaled,
        user_collateral_scaled_before - expected_liquidated_collateral_amount_scaled
    );

    // liquidator's collateral should be empty
    COLLATERALS
        .load(ts.deps.as_ref().storage, (&liquidator_addr, &ts.collateral_market.denom))
        .unwrap_err();

    // recipient's collateral scaled amount should have been correctly increased
    let collateral = COLLATERALS
        .load(ts.deps.as_ref().storage, (&recipient_addr, &ts.collateral_market.denom))
        .unwrap();
    assert_eq!(collateral.amount_scaled, expected_liquidated_collateral_amount_scaled);

    // check user's debt decreased by the appropriate amount
    let debt = DEBTS.load(&ts.deps.storage, (&user_addr, &ts.debt_market.denom)).unwrap();
    assert_eq!(debt.amount_scaled, user_debt_scaled_before - expected_debt_rates.less_debt_scaled);

    // check global debt decreased by the appropriate amount
    assert_eq!(
        debt_market_after.debt_total_scaled,
        ts.debt_market.debt_total_scaled - expected_debt_rates.less_debt_scaled
    );

    // rewards collector's collateral scaled amount **of the debt asset** should have been correctly increased
    let collateral = rewards_collector_collateral(ts.deps.as_ref(), &ts.debt_market.denom);
    assert_eq!(collateral.amount_scaled, expected_reward_amount_scaled);

    // global collateral scaled amount **of the debt asset** should have been correctly increased
    assert_eq!(
        debt_market_after.collateral_total_scaled,
        ts.debt_market.collateral_total_scaled + expected_reward_amount_scaled
    );
}

#[test]
fn liquidation_health_factor_check() {
    // initialize collateral and debt markets
    let available_liquidity_collateral = Uint128::from(1000000000u128);
    let available_liquidity_debt = Uint128::from(2000000000u128);
    let mut deps = th_setup(&[
        coin(available_liquidity_collateral.into(), "collateral"),
        coin(available_liquidity_debt.into(), "debt"),
    ]);

    deps.querier.set_oracle_price("collateral", Decimal::one());
    deps.querier.set_oracle_price("debt", Decimal::one());
    deps.querier.set_oracle_price("uncollateralized_debt", Decimal::one());

    let collateral_ltv = Decimal::from_ratio(5u128, 10u128);
    let collateral_liquidation_threshold = Decimal::from_ratio(7u128, 10u128);
    let collateral_liquidation_bonus = Decimal::from_ratio(1u128, 10u128);

    let collateral_market = Market {
        max_loan_to_value: collateral_ltv,
        liquidation_threshold: collateral_liquidation_threshold,
        liquidation_bonus: collateral_liquidation_bonus,
        debt_total_scaled: Uint128::zero(),
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        ..Default::default()
    };
    let debt_market = Market {
        max_loan_to_value: Decimal::from_ratio(6u128, 10u128),
        debt_total_scaled: Uint128::new(20_000_000) * SCALING_FACTOR,
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        ..Default::default()
    };
    let uncollateralized_debt_market = Market {
        denom: "uncollateralized_debt".to_string(),
        ..Default::default()
    };

    // initialize markets
    th_init_market(deps.as_mut(), "collateral", &collateral_market);
    th_init_market(deps.as_mut(), "debt", &debt_market);
    th_init_market(deps.as_mut(), "uncollateralized_debt", &uncollateralized_debt_market);

    // test health factor check
    let healthy_user_addr = Addr::unchecked("healthy_user");

    // set initial collateral and debt balances for user
    let healthy_user_collateral_balance_scaled = Uint128::new(10_000_000) * SCALING_FACTOR;
    set_collateral(
        deps.as_mut(),
        &healthy_user_addr,
        "collateral",
        healthy_user_collateral_balance_scaled,
        true,
    );

    let healthy_user_debt_amount_scaled =
        Uint128::new(healthy_user_collateral_balance_scaled.u128())
            * collateral_liquidation_threshold;
    let healthy_user_debt = Debt {
        amount_scaled: healthy_user_debt_amount_scaled,
        uncollateralized: false,
    };
    let uncollateralized_debt = Debt {
        amount_scaled: Uint128::new(10_000) * SCALING_FACTOR,
        uncollateralized: true,
    };
    DEBTS.save(deps.as_mut().storage, (&healthy_user_addr, "debt"), &healthy_user_debt).unwrap();
    DEBTS
        .save(
            deps.as_mut().storage,
            (&healthy_user_addr, "uncollateralized_debt"),
            &uncollateralized_debt,
        )
        .unwrap();

    // perform liquidation (should fail because health factor is > 1)
    let liquidator_addr = Addr::unchecked("liquidator");
    let debt_to_cover = Uint128::from(1_000_000u64);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: healthy_user_addr.to_string(),
        collateral_denom: "collateral".to_string(),
        recipient: None,
    };

    let env = mock_env(MockEnvParams::default());
    let info = mock_info(liquidator_addr.as_str(), &coins(debt_to_cover.u128(), "debt"));
    let error_res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap_err();
    assert_eq!(error_res, ContractError::CannotLiquidateHealthyPosition {});
}

#[test]
fn liquidate_if_collateral_disabled() {
    // initialize collateral and debt markets
    let mut deps = th_setup(&[]);

    let collateral_market_1 = Market {
        ..Default::default()
    };
    let collateral_market_2 = Market {
        ..Default::default()
    };
    let debt_market = Market {
        ..Default::default()
    };

    // initialize markets
    th_init_market(deps.as_mut(), "collateral1", &collateral_market_1);
    th_init_market(deps.as_mut(), "collateral2", &collateral_market_2);
    th_init_market(deps.as_mut(), "debt", &debt_market);

    // Set user as having collateral and debt in respective markets
    let user_addr = Addr::unchecked("user");
    set_collateral(deps.as_mut(), &user_addr, "collateral1", Uint128::new(123), true);
    set_collateral(deps.as_mut(), &user_addr, "collateral2", Uint128::new(123), false);

    // perform liquidation (should fail because collateral2 isn't set as collateral for user)
    let liquidator_addr = Addr::unchecked("liquidator");
    let debt_to_cover = Uint128::from(1_000_000u64);

    let liquidate_msg = ExecuteMsg::Liquidate {
        user: user_addr.to_string(),
        collateral_denom: "collateral2".to_string(),
        recipient: None,
    };

    let env = mock_env(MockEnvParams::default());
    let info = mock_info(liquidator_addr.as_str(), &coins(debt_to_cover.u128(), "debt"));
    let error_res = execute(deps.as_mut(), env, info, liquidate_msg).unwrap_err();
    assert_eq!(
        error_res,
        ContractError::CannotLiquidateWhenCollateralUnset {
            denom: "collateral2".to_string()
        }
    );
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)      | `String`       | The address of the borrower getting liquidated       |
| [`collateral_denom`](focus://json#4)      | `String`       | Denom of the collateral asset, which liquidator gets from the borrower       |
| [`recipient`](focus://json#5)      | `Option<String>`       | The address for receiving underlying collateral       |

</CH.Section>

<img src={RedBankLiquidateUrl} />


### `update_asset_collateral_status`

Update (enable/disable) asset as collateral for the caller.

<CH.Section>
<CH.Code>

```json json
{
    "update_asset_collateral_status": {
        "denom": "...", 
        "enable": true
    }
}
```

```rust msg.rs focus=1:3,41:45
#[cw_serde]
#[allow(clippy::large_enum_variant)]
pub enum ExecuteMsg {
    UpdateConfig {
        config: CreateOrUpdateConfig,
    },
    InitAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateAsset {
        denom: String,
        params: InitOrUpdateAssetParams,
    },
    UpdateUncollateralizedLoanLimit {
        user: String,
        denom: String,
        new_limit: Uint128,
    },
    Deposit {
        on_behalf_of: Option<String>,
    },
    Withdraw {
        denom: String,
        amount: Option<Uint128>,
        recipient: Option<String>,
    },
    Borrow {
        denom: String,
        amount: Uint128,
        recipient: Option<String>,
    },
    Repay {
        on_behalf_of: Option<String>,
    },
    Liquidate {
        user: String,
        collateral_denom: String,
        recipient: Option<String>,
    },
    UpdateAssetCollateralStatus {
        denom: String,
        enable: bool,
    },
}
```

```rust contract.rs focus=1:8,68:73
#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::UpdateConfig {
            config,
        } => execute::update_config(deps, info, config),
        ExecuteMsg::InitAsset {
            denom,
            params,
        } => execute::init_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateAsset {
            denom,
            params,
        } => execute::update_asset(deps, env, info, denom, params),
        ExecuteMsg::UpdateUncollateralizedLoanLimit {
            user,
            denom,
            new_limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            execute::update_uncollateralized_loan_limit(deps, info, user_addr, denom, new_limit)
        }
        ExecuteMsg::Deposit {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::deposit(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Withdraw {
            denom,
            amount,
            recipient,
        } => execute::withdraw(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Borrow {
            denom,
            amount,
            recipient,
        } => execute::borrow(deps, env, info, denom, amount, recipient),
        ExecuteMsg::Repay {
            on_behalf_of,
        } => {
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::repay(deps, env, info, on_behalf_of, sent_coin.denom, sent_coin.amount)
        }
        ExecuteMsg::Liquidate {
            user,
            collateral_denom,
            recipient,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            let sent_coin = cw_utils::one_coin(&info)?;
            execute::liquidate(
                deps,
                env,
                info,
                collateral_denom,
                sent_coin.denom,
                user_addr,
                sent_coin.amount,
                recipient,
            )
        }
        ExecuteMsg::UpdateAssetCollateralStatus {
            denom,
            enable,
        } => execute::update_asset_collateral_status(deps, env, info, denom, enable),
    }
}
```

```rust execute.rs
pub fn update_asset_collateral_status(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    enable: bool,
) -> Result<Response, ContractError> {
    let user = User(&info.sender);

    let mut collateral =
        COLLATERALS.may_load(deps.storage, (user.address(), &denom))?.ok_or_else(|| {
            ContractError::UserNoCollateralBalance {
                user: user.into(),
                denom: denom.clone(),
            }
        })?;

    let previously_enabled = collateral.enabled;

    collateral.enabled = enable;
    COLLATERALS.save(deps.storage, (user.address(), &denom), &collateral)?;

    // if the collateral was previously enabled, but is not disabled, it is necessary to ensure the
    // user is not liquidatable after disabling
    if previously_enabled && !enable {
        let config = CONFIG.load(deps.storage)?;
        let oracle_addr = address_provider::helpers::query_address(
            deps.as_ref(),
            &config.address_provider,
            MarsAddressType::Oracle,
        )?;

        let (liquidatable, _) =
            assert_liquidatable(&deps.as_ref(), &env, user.address(), &oracle_addr)?;

        if liquidatable {
            return Err(ContractError::InvalidHealthFactorAfterDisablingCollateral {});
        }
    }

    Ok(Response::new()
        .add_attribute("action", "outposts/red-bank/update_asset_collateral_status")
        .add_attribute("user", user)
        .add_attribute("denom", denom)
        .add_attribute("enable", enable.to_string()))
}
```

```rust test
#[test]
fn test_update_asset_collateral() {
    let mut deps = th_setup(&[]);

    let user_addr = Addr::unchecked(String::from("user"));

    let denom_1 = "depositedcoin1";
    let mock_market_1 = Market {
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::one(),
        max_loan_to_value: Decimal::from_ratio(40u128, 100u128),
        liquidation_threshold: Decimal::from_ratio(60u128, 100u128),
        ..Default::default()
    };
    let denom_2 = "depositedcoin2";
    let mock_market_2 = Market {
        liquidity_index: Decimal::from_ratio(1u128, 2u128),
        borrow_index: Decimal::one(),
        max_loan_to_value: Decimal::from_ratio(50u128, 100u128),
        liquidation_threshold: Decimal::from_ratio(80u128, 100u128),
        ..Default::default()
    };
    let denom_3 = "depositedcoin3";
    let mock_market_3 = Market {
        liquidity_index: Decimal::one(),
        borrow_index: Decimal::from_ratio(2u128, 1u128),
        max_loan_to_value: Decimal::from_ratio(20u128, 100u128),
        liquidation_threshold: Decimal::from_ratio(40u128, 100u128),
        ..Default::default()
    };

    let market_1_initial = th_init_market(deps.as_mut(), denom_1, &mock_market_1);
    let market_2_initial = th_init_market(deps.as_mut(), denom_2, &mock_market_2);
    let market_3_initial = th_init_market(deps.as_mut(), denom_3, &mock_market_3);

    // Set the querier to return exchange rates
    let token_1_exchange_rate = Decimal::from_ratio(2u128, 1u128);
    let token_2_exchange_rate = Decimal::from_ratio(3u128, 1u128);
    let token_3_exchange_rate = Decimal::from_ratio(4u128, 1u128);
    deps.querier.set_oracle_price(denom_1, token_1_exchange_rate);
    deps.querier.set_oracle_price(denom_2, token_2_exchange_rate);
    deps.querier.set_oracle_price(denom_3, token_3_exchange_rate);

    let env = mock_env(MockEnvParams::default());
    let info = mock_info(user_addr.as_str(), &[]);

    {
        // Set second asset as collateral
        set_collateral(deps.as_mut(), &user_addr, &market_2_initial.denom, Uint128::new(123), true);

        // Enable denom 1 as collateral in which the user currently doesn't have a position in
        let update_msg = ExecuteMsg::UpdateAssetCollateralStatus {
            denom: denom_1.to_string(),
            enable: true,
        };
        let error_res =
            execute(deps.as_mut(), env.clone(), info.clone(), update_msg.clone()).unwrap_err();
        assert_eq!(
            error_res,
            ContractError::UserNoCollateralBalance {
                user: user_addr.to_string(),
                denom: denom_1.to_string()
            }
        );

        // Balance for first asset is zero so don't update bit
        assert!(!has_collateral_position(deps.as_ref(), &user_addr, &market_1_initial.denom));

        // Set the querier to return balance more than zero for the first asset
        set_collateral(deps.as_mut(), &user_addr, denom_1, Uint128::new(100_000), false);

        // Enable first market index which is currently disabled as collateral and ma-token balance is more than 0
        execute(deps.as_mut(), env.clone(), info.clone(), update_msg).unwrap();
        assert!(has_collateral_enabled(deps.as_ref(), &user_addr, &market_1_initial.denom));

        // Disable second market index
        let update_msg = ExecuteMsg::UpdateAssetCollateralStatus {
            denom: denom_2.to_string(),
            enable: false,
        };
        execute(deps.as_mut(), env.clone(), info.clone(), update_msg).unwrap();
        assert!(!has_collateral_enabled(deps.as_ref(), &user_addr, &market_2_initial.denom));
    }

    // User's health factor can't be less than 1 after disabling collateral
    {
        // Initialize user with market_1 and market_2 as collaterals
        // User borrows market_3, which will be set up later in the test
        let ma_token_1_balance_scaled = Uint128::new(150_000) * SCALING_FACTOR;
        set_collateral(
            deps.as_mut(),
            &user_addr,
            &market_1_initial.denom,
            ma_token_1_balance_scaled,
            true,
        );
        let ma_token_2_balance_scaled = Uint128::new(220_000) * SCALING_FACTOR;
        set_collateral(
            deps.as_mut(),
            &user_addr,
            &market_2_initial.denom,
            ma_token_2_balance_scaled,
            true,
        );

        // Calculate maximum debt for the user to have valid health factor
        let token_1_weighted_lt_in_base_asset = compute_underlying_amount(
            ma_token_1_balance_scaled,
            get_updated_liquidity_index(&market_1_initial, env.block.time.seconds()).unwrap(),
            ScalingOperation::Truncate,
        )
        .unwrap()
            * market_1_initial.liquidation_threshold
            * token_1_exchange_rate;
        let token_2_weighted_lt_in_base_asset = compute_underlying_amount(
            ma_token_2_balance_scaled,
            get_updated_liquidity_index(&market_2_initial, env.block.time.seconds()).unwrap(),
            ScalingOperation::Truncate,
        )
        .unwrap()
            * market_2_initial.liquidation_threshold
            * token_2_exchange_rate;
        let weighted_liquidation_threshold_in_base_asset =
            token_1_weighted_lt_in_base_asset + token_2_weighted_lt_in_base_asset;
        let max_debt_for_valid_hf = math::divide_uint128_by_decimal(
            weighted_liquidation_threshold_in_base_asset,
            token_3_exchange_rate,
        )
        .unwrap();
        let token_3_debt_scaled = get_scaled_debt_amount(
            max_debt_for_valid_hf,
            &market_3_initial,
            env.block.time.seconds(),
        )
        .unwrap();

        // Set user to have max debt for valid health factor
        let debt = Debt {
            amount_scaled: token_3_debt_scaled,
            uncollateralized: false,
        };
        DEBTS.save(deps.as_mut().storage, (&user_addr, denom_3), &debt).unwrap();

        let positions = health::get_user_positions_map(
            &deps.as_ref(),
            &env,
            &user_addr,
            &Addr::unchecked("oracle"),
        )
        .unwrap();
        let health = health::compute_position_health(&positions).unwrap();

        // Should have valid health factor
        assert_eq!(health.liquidation_health_factor.unwrap(), Decimal::one());

        // Disable second market index
        let update_msg = ExecuteMsg::UpdateAssetCollateralStatus {
            denom: denom_2.to_string(),
            enable: false,
        };
        let res_error = execute(deps.as_mut(), env, info, update_msg).unwrap_err();
        assert_eq!(res_error, ContractError::InvalidHealthFactorAfterDisablingCollateral {})
    }
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)      | `String`       | Asset to update status for       |
| [`enable`](focus://json#4)      | `bool`       | Option to enable (true) / disable (false) asset as collateral       |


</CH.Section>

## QueryMsg

### `config`

Get config.

<CH.Section>
<CH.Code>

```json json
{
    "config": {}
}
```

```rust msg.rs focus=1:5,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:4,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {
    let config = CONFIG.load(deps.storage)?;
    Ok(ConfigResponse {
        owner: config.owner.to_string(),
        address_provider: config.address_provider.to_string(),
        close_factor: config.close_factor,
    })
}
```


</CH.Code>
</CH.Section>

#### `ConfigResponse`

<CH.Section>
<CH.Code>

```json json
{
    "config": {
        "owner": "...", 
        "address_provider": "...", 
        "close_factor": 0.123
    }
}
```

```rust types.rs
pub type ConfigResponse = Config<String>;
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`config`](focus://json#2:6)      | [`Config<T>`](#configt)       | Config parameters       |


</CH.Section>

#### `Config<T>`

<CH.Section>
<CH.Code>

```json json
{
    "owner": "...",
    "address_provider": "...",
    "close_factor": 0.123
}
```

```rust types.rs
#[cw_serde]
pub struct Config<T> {
    pub owner: T,
    pub address_provider: T,
    pub close_factor: Decimal,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`owner`](focus://json#2)      | `T`       | Contract owner       |
| [`address_provider`](focus://json#3)      | `T`       | Address provider returns addresses for all protocol contracts       |
| [`close_factor`](focus://json#4)      | `Decimal`       | Maximum percentage of outstanding debt that can be covered by a liquidator       |

</CH.Section>

### `market`

Get asset market.

<CH.Section>
<CH.Code>

```json json
{
    "market": {
        "denom": "..."
    }
}
```

```rust msg.rs focus=1:3,6:9,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,5:7,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_market(deps: Deps, denom: String) -> StdResult<Market> {
    MARKETS
        .load(deps.storage, &denom)
        .map_err(|_| StdError::generic_err(format!("failed to load market for: {}", denom)))
}
```

</CH.Code>
</CH.Section>

#### `Market` (response)

<CH.Section>
<CH.Code>

```json json
{
    "denom": "...", 
    "max_loan_to_value": 0.123,
    "liquidation_threshold": 0.123,
    "liquidation_bonus": 0.123, 
    "reserve_factor": 0.123, 
    "interest_rate_model": {
        "optimal_utilization_rate": 0.123, 
        "base": 0.123, 
        "slope_1": 0.123, 
        "slope_2": 0.123
    }, 
    "borrow_index": 0.123, 
    "liquidity_index": 0.123, 
    "borrow_rate": 0.123, 
    "liquidity_rate": 0.123, 
    "indexes_last_updated": 123,
    "collateral_total_scaled": 123,
    "debt_total_scaled": 123,
    "deposit_enabled": true, 
    "borrow_enabled": true, 
    "deposit_cap": 123456
}
```

```rust market.rs
#[cw_serde]
pub struct Market {
    pub denom: String,
    pub max_loan_to_value: Decimal,
    pub liquidation_threshold: Decimal,
    pub liquidation_bonus: Decimal,
    pub reserve_factor: Decimal,
    pub interest_rate_model: InterestRateModel,
    pub borrow_index: Decimal,
    pub liquidity_index: Decimal,
    pub borrow_rate: Decimal,
    pub liquidity_rate: Decimal,
    pub indexes_last_updated: u64,
    pub collateral_total_scaled: Uint128,
    pub debt_total_scaled: Uint128,
    pub deposit_enabled: bool,
    pub borrow_enabled: bool,
    pub deposit_cap: Uint128,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#2)      | `String`       | Denom of the asset       |
| [`max_loan_to_value`](focus://json#3)      | `Decimal`       | Max base asset that can be borrowed per "base asset" collateral when using the asset as collateral       |
| [`liquidation_threshold`](focus://json#4)      | `Decimal`       | Base asset amount in debt position per "base asset" of asset collateral that if surpassed makes the user's position liquidatable       |
| [`liquidation_bonus`](focus://json#5)      | `Decimal`       | Bonus amount of collateral liquidator get when repaying user's debt (Will get collateral from user in an amount equal to debt repayed + bonus)       |
| [`reserve_factor`](focus://json#6)      | `Decimal`       | Portion of the borrow rate that is kept as protocol rewards       |
| [`interest_rate_model`](focus://json#7:12)      | [`InterestRateModel`](#interestratemodel)       | model (params + internal state) that defines how interest rate behaves       |
| [`borrow_index`](focus://json#13)      | `Decimal`       | Borrow index (Used to compute borrow interest)       |
| [`liquidity_index`](focus://json#14)      | `Decimal`       | Liquidity index (Used to compute deposit interest)       |
| [`borrow_rate`](focus://json#15)      | `Decimal`       | Rate charged to borrowers       |
| [`liquidity_rate`](focus://json#16)      | `Decimal`       | Rate paid to depositors       |
| [`indexes_last_updated`](focus://json#17)      | `u64`       | Timestamp (seconds) where indexes and where last updated       |
| [`collateral_total_scaled`](focus://json#18)      | `Uint128`       | Total collateral scaled for the market's currency       |
| [`debt_total_scaled`](focus://json#19)      | `Uint128`       | Total debt scaled for the market's currency       |
| [`deposit_enabled`](focus://json#20)      | `bool`       | If false cannot deposit       |
| [`borrow_enabled`](focus://json#21)      | `bool`       | If false cannot borrow       |
| [`deposit_cap`](focus://json#22)      | `Uint128`       | Deposit Cap (defined in terms of the asset)       |

</CH.Section>

### `markets`

Enumerate markets with pagination.

<CH.Section>
<CH.Code>

```json json
{
    "markets": {
        "start_after": "...", 
        "limit": 10
    }
}
```

```rust msg.rs focus=1:3,10:14,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,8:11,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_markets(
    deps: Deps,
    start_after: Option<String>,
    limit: Option<u32>,
) -> StdResult<Vec<Market>> {
    let start = start_after.map(|denom| Bound::ExclusiveRaw(denom.into_bytes()));
    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;

    MARKETS
        .range(deps.storage, start, None, Order::Ascending)
        .take(limit)
        .map(|item| {
            let (_, market) = item?;
            Ok(market)
        })
        .collect()
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`start_after`](focus://json#3)   | `Option<String>`       | A market to start after |
| [`limit`](focus://json#4)   | `Option<u32>`       | The amount of markets to list |

</CH.Section>

#### `Vec<crate::red_bank::Market>`

`markets` returns a vector of the [`Market`](#market) response struct defined above.

### `uncollateralized_loan_limit`

Get uncollateralized limit for given user and asset.

<CH.Section>
<CH.Code>

```json json
{
    "uncollateralized_loan_limit": {
        "user": "mars...", 
        "denom": "..."
    }
}
```

```rust msg.rs focus=1:3,15:19,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,12:18,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_uncollateralized_loan_limit(
    deps: Deps,
    user_addr: Addr,
    denom: String,
) -> StdResult<UncollateralizedLoanLimitResponse> {
    let limit = UNCOLLATERALIZED_LOAN_LIMITS.may_load(deps.storage, (&user_addr, &denom))?;
    Ok(UncollateralizedLoanLimitResponse {
        denom,
        limit: limit.unwrap_or_else(Uint128::zero),
    })
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with uncollateralized loan |
| [`denom`](focus://json#4)   | `String`       | Asset denom |


</CH.Section>


#### `UncollateralizedLoanLimitResponse`

<CH.Section>
<CH.Code>

```json json
{
    "denom": "...", 
    "limit": 123
}
```

```rust types.rs
#[cw_serde]
pub struct UncollateralizedLoanLimitResponse {
    pub denom: String,
    pub limit: Uint128,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#2)   | `String`       | Asset denom |
| [`limit`](focus://json#3)   | `Uint128`       | Limit for uncollateralized loan |

</CH.Section>

### `uncollateralized_loan_limits`

Get all uncollateralized limits for a given user.

<CH.Section>
<CH.Code>

```json json
{
    "uncollateralized_loan_limits": {
        "user": "mars...", 
        "start_after": "...", 
        "limit": 123
    }
}
```

```rust msg.rs focus=1:3,20:25,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,19:31,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_uncollateralized_loan_limits(
    deps: Deps,
    user_addr: Addr,
    start_after: Option<String>,
    limit: Option<u32>,
) -> StdResult<Vec<UncollateralizedLoanLimitResponse>> {
    let start = start_after.map(|denom| Bound::ExclusiveRaw(denom.into_bytes()));
    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;

    UNCOLLATERALIZED_LOAN_LIMITS
        .prefix(&user_addr)
        .range(deps.storage, start, None, Order::Ascending)
        .take(limit)
        .map(|item| {
            let (denom, limit) = item?;
            Ok(UncollateralizedLoanLimitResponse {
                denom,
                limit,
            })
        })
        .collect()
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with uncollateralized loans |
| [`start_after`](focus://json#4)   | `Option<String>`       | The amount of loans to list |
| [`limit`](focus://json#5)   | `Option<u32>`       | Limit for uncollateralized loan |


</CH.Section>

#### `Vec<crate::red_bank::UncollateralizedLoanLimitResponse>`

`uncollateralized_loan_limits` returns a vector of the [`UncollateralizedLoanLimitResponse`](#uncollateralizedloanlimitresponse) struct defined above. 

### `user_debt`

Get user debt position for a specific asset.

<CH.Section>
<CH.Code>

```json json
{
    "user_debt": {
        "user": "mars...", 
        "denom": "..."
    }
}
```

```rust msg.rs focus=1:3,26:30,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,32:38,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_user_debt(
    deps: Deps,
    block: &BlockInfo,
    user_addr: Addr,
    denom: String,
) -> StdResult<UserDebtResponse> {
    let Debt {
        amount_scaled,
        uncollateralized,
    } = DEBTS.may_load(deps.storage, (&user_addr, &denom))?.unwrap_or_default();

    let block_time = block.time.seconds();
    let market = MARKETS.load(deps.storage, &denom)?;
    let amount = get_underlying_debt_amount(amount_scaled, &market, block_time)?;

    Ok(UserDebtResponse {
        denom,
        amount_scaled,
        amount,
        uncollateralized,
    })
}
```

```rust test
#[test]
fn test_query_user_debt() {
    let mut deps = th_setup(&[]);

    let user_addr = Addr::unchecked("user");

    // Setup markets
    let market_1_initial = th_init_market(
        deps.as_mut(),
        "coin_1",
        &Market {
            borrow_index: Decimal::one(),
            borrow_rate: Decimal::one(),
            ..Default::default()
        },
    );
    let _market_2_initial = th_init_market(
        deps.as_mut(),
        "coin_2",
        &Market {
            borrow_index: Decimal::one(),
            borrow_rate: Decimal::one(),
            ..Default::default()
        },
    );
    let market_3_initial = th_init_market(
        deps.as_mut(),
        "coin_3",
        &Market {
            borrow_index: Decimal::one(),
            borrow_rate: Decimal::one(),
            ..Default::default()
        },
    );

    let env = mock_env();

    // Save debt for market 1
    let debt_amount_1 = Uint128::new(1234000u128);
    let debt_amount_scaled_1 =
        get_scaled_debt_amount(debt_amount_1, &market_1_initial, env.block.time.seconds()).unwrap();
    let debt_amount_at_query_1 = get_underlying_debt_amount(
        debt_amount_scaled_1,
        &market_1_initial,
        env.block.time.seconds(),
    )
    .unwrap();
    let debt_1 = Debt {
        amount_scaled: debt_amount_scaled_1,
        uncollateralized: false,
    };
    DEBTS.save(deps.as_mut().storage, (&user_addr, "coin_1"), &debt_1).unwrap();

    // Save debt for market 3
    let debt_amount_3 = Uint128::new(2221u128);
    let debt_amount_scaled_3 =
        get_scaled_debt_amount(debt_amount_3, &market_3_initial, env.block.time.seconds()).unwrap();
    let debt_amount_at_query_3 = get_underlying_debt_amount(
        debt_amount_scaled_3,
        &market_3_initial,
        env.block.time.seconds(),
    )
    .unwrap();
    let debt_3 = Debt {
        amount_scaled: debt_amount_scaled_3,
        uncollateralized: false,
    };
    DEBTS.save(deps.as_mut().storage, (&user_addr, "coin_3"), &debt_3).unwrap();

    let debts = query_user_debts(deps.as_ref(), &env.block, user_addr, None, None).unwrap();
    assert_eq!(debts.len(), 2);
    assert_eq!(
        debts[0],
        UserDebtResponse {
            denom: "coin_1".to_string(),
            amount_scaled: debt_amount_scaled_1,
            amount: debt_amount_at_query_1,
            uncollateralized: false,
        }
    );
    assert_eq!(
        debts[1],
        UserDebtResponse {
            denom: "coin_3".to_string(),
            amount_scaled: debt_amount_scaled_3,
            amount: debt_amount_at_query_3,
            uncollateralized: false,
        }
    );
}

#[test]
fn test_query_user_asset_debt() {
    let mut deps = th_setup(&[]);

    let user_addr = Addr::unchecked("user");

    // Setup markets
    let market_1_initial = th_init_market(
        deps.as_mut(),
        "coin_1",
        &Market {
            borrow_index: Decimal::one(),
            borrow_rate: Decimal::one(),
            ..Default::default()
        },
    );
    let _market_2_initial = th_init_market(
        deps.as_mut(),
        "coin_2",
        &Market {
            borrow_index: Decimal::one(),
            borrow_rate: Decimal::one(),
            ..Default::default()
        },
    );

    let env = mock_env();

    // Save debt for market 1
    let debt_amount_1 = Uint128::new(1234567u128);
    let debt_amount_scaled_1 =
        get_scaled_debt_amount(debt_amount_1, &market_1_initial, env.block.time.seconds()).unwrap();
    let debt_amount_at_query_1 = get_underlying_debt_amount(
        debt_amount_scaled_1,
        &market_1_initial,
        env.block.time.seconds(),
    )
    .unwrap();
    let debt_1 = Debt {
        amount_scaled: debt_amount_scaled_1,
        uncollateralized: false,
    };
    DEBTS.save(deps.as_mut().storage, (&user_addr, "coin_1"), &debt_1).unwrap();

    // Check asset with existing debt
    {
        let res =
            query_user_debt(deps.as_ref(), &env.block, user_addr.clone(), "coin_1".to_string())
                .unwrap();
        assert_eq!(
            res,
            UserDebtResponse {
                denom: "coin_1".to_string(),
                amount_scaled: debt_amount_scaled_1,
                amount: debt_amount_at_query_1,
                uncollateralized: false,
            }
        );
    }

    // Check asset with no debt
    {
        let res =
            query_user_debt(deps.as_ref(), &env.block, user_addr, "coin_2".to_string()).unwrap();
        assert_eq!(
            res,
            UserDebtResponse {
                denom: "coin_2".to_string(),
                amount_scaled: Uint128::zero(),
                amount: Uint128::zero(),
                uncollateralized: false,
            }
        );
    }
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with debt |
| [`denom`](focus://json#4)   | `String`       | Asset denom |

</CH.Section>

#### `UserDebtResponse`

<CH.Section>
<CH.Code>

```json json
{
    "denom": "...", 
    "amount_scaled": 123,
    "amount": 123, 
    "uncollateralized": false
}
```

```rust types.rs
#[cw_serde]
pub struct UserDebtResponse {
    pub denom: String,
    pub amount_scaled: Uint128,
    pub amount: Uint128,
    pub uncollateralized: bool,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#2)   | `String`       | Asset denom |
| [`amount_scaled`](focus://json#3)   | `Uint128`       | Scaled debt amount stored in contract state |
| [`amount`](focus://json#4)   | `Uint128`       | Underlying asset amount that is actually owed at the current block |
| [`uncollateralized`](focus://json#5)   | `bool`       | Marker for uncollateralized debt |

</CH.Section>

### `user_debts`

Get all debt positions for a user.

<CH.Section>
<CH.Code>

```json json
{
    "user_debts": {
        "user": "...", 
        "start_after": "...", 
        "limit": 123
    }
}
```

```rust msg.rs focus=1:3,31:36,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,39:46,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_user_debts(
    deps: Deps,
    block: &BlockInfo,
    user_addr: Addr,
    start_after: Option<String>,
    limit: Option<u32>,
) -> StdResult<Vec<UserDebtResponse>> {
    let block_time = block.time.seconds();

    let start = start_after.map(|denom| Bound::ExclusiveRaw(denom.into_bytes()));
    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;

    DEBTS
        .prefix(&user_addr)
        .range(deps.storage, start, None, Order::Ascending)
        .take(limit)
        .map(|item| {
            let (denom, debt) = item?;

            let market = MARKETS.load(deps.storage, &denom)?;

            let amount_scaled = debt.amount_scaled;
            let amount = get_underlying_debt_amount(amount_scaled, &market, block_time)?;

            Ok(UserDebtResponse {
                denom,
                amount_scaled,
                amount,
                uncollateralized: debt.uncollateralized,
            })
        })
        .collect()
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with debt |
| [`start_after`](focus://json#4)   | `Option<String>`       | Position to start after |
| [`limit`](focus://json#5)   | `Option<u32>`       | The amount of positions to list |

</CH.Section>

#### `Vec<crate::red_bank::UserDebtResponse>`

`user_debts`  returns a vector of the [`UserDebtResponse`](#userdebtresponse) struct defined above.

### `user_collateral`

Get user collateral position for a specific asset.

<CH.Section>
<CH.Code>

```json json
{
    "user_collateral": {
        "user": "mars...",
        "denom": "..."
    }
}
```

```rust msg.rs focus=1:3,37:41,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,47:53,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_user_collateral(
    deps: Deps,
    block: &BlockInfo,
    user_addr: Addr,
    denom: String,
) -> StdResult<UserCollateralResponse> {
    let Collateral {
        amount_scaled,
        enabled,
    } = COLLATERALS.may_load(deps.storage, (&user_addr, &denom))?.unwrap_or_default();

    let block_time = block.time.seconds();
    let market = MARKETS.load(deps.storage, &denom)?;
    let amount = get_underlying_liquidity_amount(amount_scaled, &market, block_time)?;

    Ok(UserCollateralResponse {
        denom,
        amount_scaled,
        amount,
        enabled,
    })
}
```

```rust test
#[test]
fn test_query_collateral() {
    let mut deps = th_setup(&[]);

    let user_addr = Addr::unchecked("user");

    // Setup first market
    let market_1 = th_init_market(
        deps.as_mut(),
        "uosmo",
        &Market {
            ..Default::default()
        },
    );

    // Setup second market
    let market_2 = th_init_market(
        deps.as_mut(),
        "uusd",
        &Market {
            ..Default::default()
        },
    );

    let amount_1 = Uint128::new(12345);
    let amount_2 = Uint128::new(54321);

    let env = mock_env();

    // Create and enable a collateral position for the 2nd asset
    set_collateral(deps.as_mut(), &user_addr, &market_2.denom, amount_2 * SCALING_FACTOR, true);

    // Assert markets correctly return collateral status
    let collaterals =
        query_user_collaterals(deps.as_ref(), &env.block, user_addr.clone(), None, None).unwrap();
    assert_eq!(
        collaterals,
        vec![UserCollateralResponse {
            denom: market_2.denom.clone(),
            amount_scaled: amount_2 * SCALING_FACTOR,
            amount: amount_2,
            enabled: true,
        }]
    );

    // Create a collateral position for the 1st asset, but not enabled
    set_collateral(deps.as_mut(), &user_addr, &market_1.denom, amount_1 * SCALING_FACTOR, false);

    // Assert markets correctly return collateral status
    let collaterals =
        query_user_collaterals(deps.as_ref(), &env.block, user_addr, None, None).unwrap();
    assert_eq!(
        collaterals,
        vec![
            UserCollateralResponse {
                denom: market_1.denom,
                amount_scaled: amount_1 * SCALING_FACTOR,
                amount: amount_1,
                enabled: false,
            },
            UserCollateralResponse {
                denom: market_2.denom,
                amount_scaled: amount_2 * SCALING_FACTOR,
                amount: amount_2,
                enabled: true,
            }
        ]
    );
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with collateral |
| [`denom`](focus://json#4)   | `String`       | Denom of the asset |

</CH.Section>

#### `UserCollateralResponse`

<CH.Section>
<CH.Code>

```json json
{
    "denom": "...",
    "amount_scaled": 123,
    "amount": 123, 
    "enabled": true
}
```

```rust types.rs
#[cw_serde]
pub struct UserCollateralResponse {
    pub denom: String,
    pub amount_scaled: Uint128,
    pub amount: Uint128,
    pub enabled: bool,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#2)   | `String`       | Asset denom |
| [`amount_scaled`](focus://json#3)   | `Uint128`       | Scaled collateral amount stored in contract state |
| [`amount`](focus://json#4)   | `Uint128`       | Underlying asset amount that is actually deposited at the current block |
| [`enabled`](focus://json#5)   | `boold`       | Wether the user is using asset as collateral or not |

</CH.Section>

### `user_collaterals`

Get all collateral positions for a user.

<CH.Section>
<CH.Code>

```json json
{
    "user_collaterals": {
        "user": "...",
        "start_after": "...",
        "limit": 123
    }
}
```

```rust msg.rs focus=1:3,42:47,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,54:67,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_user_collaterals(
    deps: Deps,
    block: &BlockInfo,
    user_addr: Addr,
    start_after: Option<String>,
    limit: Option<u32>,
) -> StdResult<Vec<UserCollateralResponse>> {
    let block_time = block.time.seconds();

    let start = start_after.map(|denom| Bound::ExclusiveRaw(denom.into_bytes()));
    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;

    COLLATERALS
        .prefix(&user_addr)
        .range(deps.storage, start, None, Order::Ascending)
        .take(limit)
        .map(|item| {
            let (denom, collateral) = item?;

            let market = MARKETS.load(deps.storage, &denom)?;

            let amount_scaled = collateral.amount_scaled;
            let amount = get_underlying_liquidity_amount(amount_scaled, &market, block_time)?;

            Ok(UserCollateralResponse {
                denom,
                amount_scaled,
                amount,
                enabled: collateral.enabled,
            })
        })
        .collect()
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address with collateral |
| [`start_after`](focus://json#4)   | `Option<String>`       | Position to start after |
| [`limit`](focus://json#5)   | `Option<u32>`       | The amount of positions to list |

</CH.Section>

#### `UserCollateralResponse`

`user_collaterals` returns a vector of the [`UserCollateralResponse`](#usercollateralresponse) struct defined above.

### `user_position`

Get user position.

<CH.Section>
<CH.Code>

```json json
{
    "user_position": {
        "user": "mars..."
    }
}
```

```rust msg.rs focus=1:3,48:51,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,68:73,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_user_position(
    deps: Deps,
    env: Env,
    user_addr: Addr,
) -> Result<UserPositionResponse, MarsError> {
    let config = CONFIG.load(deps.storage)?;
    let oracle_addr = address_provider::helpers::query_address(
        deps,
        &config.address_provider,
        MarsAddressType::Oracle,
    )?;

    let positions = health::get_user_positions_map(&deps, &env, &user_addr, &oracle_addr)?;
    let health = health::compute_position_health(&positions)?;

    let health_status = if let (Some(max_ltv_hf), Some(liq_threshold_hf)) =
        (health.max_ltv_health_factor, health.liquidation_health_factor)
    {
        UserHealthStatus::Borrowing {
            max_ltv_hf,
            liq_threshold_hf,
        }
    } else {
        UserHealthStatus::NotBorrowing
    };

    Ok(UserPositionResponse {
        total_enabled_collateral: health.total_collateral_value,
        total_collateralized_debt: health.total_debt_value,
        weighted_max_ltv_collateral: health.max_ltv_adjusted_collateral,
        weighted_liquidation_threshold_collateral: health.liquidation_threshold_adjusted_collateral,
        health_status,
    })
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`       | User address |

</CH.Section>

#### `UserPositionResponse`

<CH.Section>
<CH.Code>

```json json
{

    "total_enabled_collateral": 0.123,
    "total_collateralized_debt": 0.123,
    "weighted_max_ltv_collateral": 0.123,
    "weighted_liquidation_threshold_collateral": 0.123,
    "health_status": {
        "max_ltv_hf": 0.123,
        "liq_threshold_hf": 0.123
    }
}
```

```rust types.rs
#[cw_serde]
pub struct UserPositionResponse {
    pub total_enabled_collateral: Decimal,
    pub total_collateralized_debt: Decimal,
    pub weighted_max_ltv_collateral: Decimal,
    pub weighted_liquidation_threshold_collateral: Decimal,
    pub health_status: UserHealthStatus,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`total_enabled_collateral`](focus://json#3)   | `Decimal`       | Total value of all enabled collateral assets. If an asset is disabled as collateral, it will not be included. |
| [`total_collateralized_debt`](focus://json#4)   | `Decimal`       | Total value of all collateralized debts. If the user has an uncollateralized loan limit in an asset, the debt in this asset will not be included. |
| [`weighted_max_ltv_collateral`](focus://json#5)   | `Decimal`       |  |
| [`weighted_liquidation_threshold_collateral`](focus://json#6)   | `Decimal`       |  |
| [`health_status`](focus://json#3)   | [`UserHealthStatus`](#userhealthstatus)       |  |


</CH.Section>



#### `UserHealthStatus`

<CH.Section>
<CH.Code>

```json json
{
    "user_health_status": {
        "not_borrowing": {}, 
        "borrowing": {
            "max_ltv_hf": 0.123,
            "liq_threshold_hf": 0.123
        }
    }
}
```

```rust types.rs
#[cw_serde]
pub enum UserHealthStatus {
    NotBorrowing,
    Borrowing {
        max_ltv_hf: Decimal,
        liq_threshold_hf: Decimal,
    },
}
```

</CH.Code>

Params when borrowing.  

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`max_ltv_hf`](focus://json#5)   | `Decimal`       |  |
| [`liq_threshold_hf`](focus://json#6)   | `Decimal`       |  |

</CH.Section>


### `scaled_liquidity_amount`

Get liquidity scaled amount for a given underlying asset amount. (i.e: how much scaled collateral is added if the given amount is deposited).

<CH.Section>
<CH.Code>

```json json
{
    "scaled_liquidity_amount": {
        "denom": "...", 
        "amount_scaled": 123
    }
}
```

```rust msg.rs focus=1:3,52:56,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,74:77,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_scaled_liquidity_amount(
    deps: Deps,
    env: Env,
    denom: String,
    amount: Uint128,
) -> StdResult<Uint128> {
    let market = MARKETS.load(deps.storage, &denom)?;
    get_scaled_liquidity_amount(amount, &market, env.block.time.seconds())
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`       | Denom of the asset |
| [`amount_scaled`](focus://json#4)   | `Uint128`       | Amount scaled by |

</CH.Section>

Returns `Uint128`

### `scaled_debt_amount`

Get equivalent scaled debt for a given underlying asset amount. (i.e: how much scaled debt is added if the given amount is borrowed).

<CH.Section>
<CH.Code>

```json json
{
    "scaled_debt_amount": {
        "denom": "...", 
        "amount": 123
    }
}
```

```rust msg.rs focus=1:3,57:61,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs focus=1:3,78:81,90:91
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_scaled_debt_amount(
    deps: Deps,
    env: Env,
    denom: String,
    amount: Uint128,
) -> StdResult<Uint128> {
    let market = MARKETS.load(deps.storage, &denom)?;
    get_scaled_debt_amount(amount, &market, env.block.time.seconds())
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`       | Denom of the asset |
| [`amount`](focus://json#4)   | `Uint128`       | Amount scaled by |

</CH.Section>

Returns `Uint128`

### `underlying_liquidity_amount`

Get underlying asset amount for a given asset and scaled amount. (i.e. How much underlying asset will be released if withdrawing by burning a given scaled collateral amount stored in state).

<CH.Section>
<CH.Code>

```json json
{
    "underlying_liquidity_amount": {
        "denom": "...",
        "amount_scaled": 123
    }
}
```

```rust msg.rs focus=1:3,62:66,72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_underlying_liquidity_amount(
    deps: Deps,
    env: Env,
    denom: String,
    amount_scaled: Uint128,
) -> StdResult<Uint128> {
    let market = MARKETS.load(deps.storage, &denom)?;
    get_underlying_liquidity_amount(amount_scaled, &market, env.block.time.seconds())
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`       | Denom of the asset |
| [`amount_scaled`](focus://json#4)   | `Uint128`       | Amount scaled by |

</CH.Section>

Returns `Uint128`

### `underlying_debt_amount`

Get underlying debt amount for a given asset and scaled amounts. (i.e: How much underlying asset needs to be repaid to cancel a given scaled debt amount stored in state).

<CH.Section>
<CH.Code>

```json json
{
    "underlying_debt_amount": {
        "denom": "...",
        "amount_scaled": 123
    }
}
```

```rust msg.rs focus=1:3,67:72
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(crate::red_bank::ConfigResponse)]
    Config {},
    #[returns(crate::red_bank::Market)]
    Market {
        denom: String,
    },
    #[returns(Vec<crate::red_bank::Market>)]
    Markets {
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UncollateralizedLoanLimitResponse)]
    UncollateralizedLoanLimit {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UncollateralizedLoanLimitResponse>)]
    UncollateralizedLoanLimits {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserDebtResponse)]
    UserDebt {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserDebtResponse>)]
    UserDebts {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserCollateralResponse)]
    UserCollateral {
        user: String,
        denom: String,
    },
    #[returns(Vec<crate::red_bank::UserCollateralResponse>)]
    UserCollaterals {
        user: String,
        start_after: Option<String>,
        limit: Option<u32>,
    },
    #[returns(crate::red_bank::UserPositionResponse)]
    UserPosition {
        user: String,
    },
    #[returns(Uint128)]
    ScaledLiquidityAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    ScaledDebtAmount {
        denom: String,
        amount: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingLiquidityAmount {
        denom: String,
        amount_scaled: Uint128,
    },
    #[returns(Uint128)]
    UnderlyingDebtAmount {
        denom: String,
        amount_scaled: Uint128,
    },
}
```

```rust contract.rs
#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query::query_config(deps)?),
        QueryMsg::Market {
            denom,
        } => to_binary(&query::query_market(deps, denom)?),
        QueryMsg::Markets {
            start_after,
            limit,
        } => to_binary(&query::query_markets(deps, start_after, limit)?),
        QueryMsg::UncollateralizedLoanLimit {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limit(deps, user_addr, denom)?)
        }
        QueryMsg::UncollateralizedLoanLimits {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_uncollateralized_loan_limits(
                deps,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserDebt {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debt(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserDebts {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_debts(deps, &env.block, user_addr, start_after, limit)?)
        }
        QueryMsg::UserCollateral {
            user,
            denom,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collateral(deps, &env.block, user_addr, denom)?)
        }
        QueryMsg::UserCollaterals {
            user,
            start_after,
            limit,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_collaterals(
                deps,
                &env.block,
                user_addr,
                start_after,
                limit,
            )?)
        }
        QueryMsg::UserPosition {
            user,
        } => {
            let user_addr = deps.api.addr_validate(&user)?;
            to_binary(&query::query_user_position(deps, env, user_addr)?)
        }
        QueryMsg::ScaledLiquidityAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_liquidity_amount(deps, env, denom, amount)?),
        QueryMsg::ScaledDebtAmount {
            denom,
            amount,
        } => to_binary(&query::query_scaled_debt_amount(deps, env, denom, amount)?),
        QueryMsg::UnderlyingLiquidityAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_liquidity_amount(deps, env, denom, amount_scaled)?),
        QueryMsg::UnderlyingDebtAmount {
            denom,
            amount_scaled,
        } => to_binary(&query::query_underlying_debt_amount(deps, env, denom, amount_scaled)?),
    }
}
```

```rust query.rs
pub fn query_underlying_debt_amount(
    deps: Deps,
    env: Env,
    denom: String,
    amount_scaled: Uint128,
) -> StdResult<Uint128> {
    let market = MARKETS.load(deps.storage, &denom)?;
    get_underlying_debt_amount(amount_scaled, &market, env.block.time.seconds())
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`       | Denom of the asset |
| [`amount_scaled`](focus://json#4)   | `Uint128`       | Amount scaled by |

</CH.Section>

Returns `Uint128`

